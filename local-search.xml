<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试页</title>
    <link href="/2025/02/20/test-page/"/>
    <url>/2025/02/20/test-page/</url>
    
    <content type="html"><![CDATA[<p>测试页面</p><h5 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h5><ul><li>型号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java code<br><br></code></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><blockquote><p>引用行</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>@FeignClient导致 RequestParam.value() was empty</title>
    <link href="/2023/12/12/FeignClient-RequestParam-value-was-empty/"/>
    <url>/2023/12/12/FeignClient-RequestParam-value-was-empty/</url>
    
    <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>最近在使用 @RequestParam、@RequestBody 注解定义 feign 接口的时候出现一些使用上的问题，造成调用方启动的时候会报错</p><h5 id="详细情况"><a href="#详细情况" class="headerlink" title="详细情况"></a>详细情况</h5><p>1.第一种情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/hello2&quot;)</span><br>BetaDto <span class="hljs-title function_">hello2</span><span class="hljs-params">(String name1)</span>;<br></code></pre></td></tr></table></figure><p>接口有且只有一个 key&#x2F;value 参数，此时可以不必在 name1 参数上使用 @RequestParam 注解。通过 Feign 调用该接口的调用方可以正常启动。</p><p>2.第二种情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/hello2&quot;)</span><br>BetaDto <span class="hljs-title function_">hello2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String name1)</span>;<br></code></pre></td></tr></table></figure><p>接口有且只有一个 key&#x2F;value 参数，此时如果对 name1 参数上使用 @RequestParam 注解，此时通过 Feign 调用该接口的调用方可启动的时候回抛出如下错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Caused <span class="hljs-keyword">by</span>: java.lang.IllegalStateException: RequestParam.<span class="hljs-built_in">value</span>() was <span class="hljs-literal">empty</span> <span class="hljs-keyword">on</span> <span class="hljs-title">parameter</span> <span class="hljs-title">0</span><br></code></pre></td></tr></table></figure><p>意思是 @RequestParam 的 value 值不允许为空，正确的姿势如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/hello2&quot;)</span><br>BetaDto <span class="hljs-title function_">hello2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name1&quot;)</span> String name1)</span>;<br></code></pre></td></tr></table></figure><p>3.第三种情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/hello2&quot;)</span><br>BetaDto <span class="hljs-title function_">hello2</span><span class="hljs-params">(String name1, String name2)</span>;<br></code></pre></td></tr></table></figure><p>接口存在多个 key&#x2F;value 参数，此时通过 Feign 调用该接口的调用方启动的时候会抛出如下错误：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Caused <span class="hljs-keyword">by</span>: java.lang.IllegalStateException: <span class="hljs-keyword">Method</span> <span class="hljs-title function_">has</span> <span class="hljs-title function_">too</span> <span class="hljs-title function_">many</span> <span class="hljs-title function_">Body</span> <span class="hljs-title function_">parameters</span><br></code></pre></td></tr></table></figure><p>像这种多参数（key&#x2F;value）的情况必须为每个参数增加 @RequestParam 注解，正确的姿势如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/hello2&quot;)</span><br>BetaDto <span class="hljs-title function_">hello2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(“name1”)</span>  String name1, <span class="hljs-meta">@RequestParam(“name2”)</span>  String name2)</span>;<br></code></pre></td></tr></table></figure><h5 id="终极办法："><a href="#终极办法：" class="headerlink" title="终极办法："></a>终极办法：</h5><p>在pom.xml的maven-compiler-plugin插件中添加配置parameters</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">parameters</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">parameters</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring框架<br>SpringBoot项目如果继承自spring-boot-starter-parent，会默认开启。</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><p>来自：<a href="https://blog.csdn.net/yangchao1125/article/details/104356936">Feign 中使用 @RequestParam、@RequestBody 的正确姿势</a></p>]]></content>
    
    
    <categories>
      
      <category>feign</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring cloud</tag>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于A method overriding another method must not redefine the parameter constraint configuration解决方法</title>
    <link href="/2023/11/11/A-method-overriding-another-method-must-not-redefine-the-parameter-constraint-configuration/"/>
    <url>/2023/11/11/A-method-overriding-another-method-must-not-redefine-the-parameter-constraint-configuration/</url>
    
    <content type="html"><![CDATA[<h4 id="关于A-method-overriding-another-method-must-not-redefine-the-parameter-constraint-configuration解决方法"><a href="#关于A-method-overriding-another-method-must-not-redefine-the-parameter-constraint-configuration解决方法" class="headerlink" title="关于A method overriding another method must not redefine the parameter constraint configuration解决方法"></a>关于A method overriding another method must not redefine the parameter constraint configuration解决方法</h4><ul><li>使用的@Validated校验参数接口参数和实现类参数要保持一直，不然会报错。</li><li>接口:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;enroll&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EduBatchApi</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取招生批次详细信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键</span><br><span class="hljs-comment">     */</span><br>    R&lt;EduBatchVo&gt; <span class="hljs-title function_">getInfo</span><span class="hljs-params">(<span class="hljs-meta">@NotNull(message = &quot;主键不能为空&quot;)</span> <span class="hljs-meta">@PathVariable</span> String id)</span>;<br></code></pre></td></tr></table></figure><ul><li>实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EduBatchController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EduBatchApi</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IEduBatchService iEduBatchService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取招生批次详细信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;EduBatchVo&gt; <span class="hljs-title function_">getInfo</span><span class="hljs-params">(<span class="hljs-meta">@NotNull(message = &quot;主键不能为空&quot;)</span> <span class="hljs-meta">@PathVariable</span> String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> R.success(iEduBatchService.queryById(id));<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> Spring Boot 整合 RabbitMQ</title>
    <link href="/2023/09/13/springboot-rabbitmq-01/"/>
    <url>/2023/09/13/springboot-rabbitmq-01/</url>
    
    <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p>RabbitMQ 是一个消息队列，说到消息队列，大家可能多多少少有听过，它主要的功能是用来实现应用服务的异步与解耦，同时也能起到削峰填谷、消息分发的作用。<br>消息队列在比较主要的一个作用是用来做应用服务的解耦，消息从消息的生产者传递到消息队列，消费者从消息队列中获取消息并进行消费，生产者不需要管是谁在消费消息，消费者也无需关注消息是由谁来生产的。在分布式的系统中，消息队列也会被用在其他地方，比如分布式事务的支持，代表如阿里开源的 RocketMQ 。<br>当然，我们本篇文章的主角还是 RabbitMQ 。</p><p>原文链接： <a href="https://juejin.cn/post/6844903966531125262">Spring Boot 整合 RabbitMQ</a></p>]]></content>
    
    
    <categories>
      
      <category>springboot rabbitmq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解 RabbitMQ Exchange</title>
    <link href="/2023/09/12/know-rabbitmq-exchange/"/>
    <url>/2023/09/12/know-rabbitmq-exchange/</url>
    
    <content type="html"><![CDATA[<h4 id="理解-RabbitMQ-Exchange"><a href="#理解-RabbitMQ-Exchange" class="headerlink" title="理解 RabbitMQ Exchange"></a>理解 RabbitMQ Exchange</h4><p>原文链接：</p><p><a href="https://zhuanlan.zhihu.com/p/37198933">理解 RabbitMQ Exchange</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring cloud config本地配置覆盖远程配置属性</title>
    <link href="/2023/09/12/spring-config-override/"/>
    <url>/2023/09/12/spring-config-override/</url>
    
    <content type="html"><![CDATA[<p>引用spring cloud config时，Spring cloud默认以远程配置为最高优先级，如果希望本地的配置文件（如application.yml或bootstrap.yml）的某些属性能覆盖远程的同名属性值，则需要在远程配置文件增加以下属性配置（以下所述属性均在PropertySourceBootstrapProperties）：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">overrideNone:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>该配置的含义是远程配置不覆盖本地配置（双重否定？太有才了）</p><p>true表示远程配置不覆盖本地同名属性</p><p>false表示远程配置覆盖本地同名属性 默认为false,（远程配置同名属性覆盖本地配置同名属性）</p><p>注意：<strong>该属性参数值需要配置在远程配置文件中</strong>，配置在本地配置文件不生效（如application.yml或bootstrap.yml）</p><p>该设置为true，则外部属性（指远程配置）具有最低的优先级，不覆盖任何本地已经存在的属性配置值。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">allowOverride:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>该配置的含义是远程配置是否允许被本地属性覆盖 默认true, <strong>该属性必须配置在远程配置</strong>（在本地配置该属性是不能生效的），<strong>该参数默认为true不需要特别设置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">overrideSystemProperties:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>该配置的含义是远程是否覆盖系统配置 默认true, <strong>该属性必须配置在远程配置中</strong>（在本地配置该属性是不能生效的）。例如，如果希望在启动时可能通过环境变量或程序参数修改某个配置，需要将该属性在远程配置中设置为false。</p><p>例：系统配置指通过命令行参数或环境变量方式 指定配置属性值.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java –jar xxx.jar --spring.cloud.stream.bindings. BusInput.group= collector-local<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring cloud config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot中@ConditionalOnProperty使用详解</title>
    <link href="/2023/09/09/springboot-ConditionalOnProperty-detail/"/>
    <url>/2023/09/09/springboot-ConditionalOnProperty-detail/</url>
    
    <content type="html"><![CDATA[<p>在Spring Boot的自动配置中经常看到@ConditionalOnProperty注解的使用，本篇文章带大家来了解一下该注解的功能。</p><h4 id="Spring-Boot中的使用"><a href="#Spring-Boot中的使用" class="headerlink" title="Spring Boot中的使用"></a>Spring Boot中的使用</h4><p>在Spring Boot的源码中，比如涉及到Http编码的自动配置、数据源类型的自动配置等大量的使用到了@ConditionalOnProperty的注解。</p><p>HttpEncodingAutoConfiguration类中部分源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@EnableConfigurationProperties(HttpProperties.class)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(CharacterEncodingFilter.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpEncodingAutoConfiguration</span> &#123;<br>    <span class="hljs-comment">// 省略内部代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>DataSourceConfiguration类中部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(DataSource.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;,</span><br><span class="hljs-meta">        matchIfMissing = true)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tomcat</span> &#123;<br>  <span class="hljs-comment">// 省略内部代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，以上两个自动配置类中都通过@ConditionalOnProperty来控制自动配置是否生效，下面我们来了解一下它的源码和具体使用。</p><h4 id="ConditionalOnProperty源码说明"><a href="#ConditionalOnProperty源码说明" class="headerlink" title="@ConditionalOnProperty源码说明"></a>@ConditionalOnProperty源码说明</h4><p>@ConditionalOnProperty注解类源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Conditional(OnPropertyCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ConditionalOnProperty &#123;<br><br>    <span class="hljs-comment">// 数组，获取对应property名称的值，与name不可同时使用</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">// 配置属性名称的前缀，比如spring.http.encoding</span><br>    String <span class="hljs-title function_">prefix</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">// 数组，配置属性完整名称或部分名称</span><br>    <span class="hljs-comment">// 可与prefix组合使用，组成完整的配置属性名称，与value不可同时使用</span><br>    String[] name() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">// 可与name组合使用，比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置</span><br>    String <span class="hljs-title function_">havingValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">// 缺少该配置属性时是否可以加载。如果为true，没有该配置属性时也会正常加载；反之则不会生效</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matchIfMissing</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过注解ConditionalOnProperty上的@Conditional(OnPropertyCondition.class)代码，可以看出ConditionalOnProperty属于@Conditional的衍生注解。生效条件由OnPropertyCondition来进行判断。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>关于@ConditionalOnProperty的使用方法，我们在上面的Spring Boot中的使用已经看到。</p><p>@ConditionalOnProperty的核心功能是通过属性name以及havingValue来实现的。</p><p>首先看matchIfMissing属性，用来指定如果配置文件中未进行对应属性配置时的默认处理：默认情况下matchIfMissing为false，也就是说如果未进行属性配置，则自动配置不生效。如果matchIfMissing为true，则表示如果没有对应的属性配置，则自动配置默认生效。</p><p>下面看name属性，name用来从application.properties中读取某个属性值。比如上面Tomcat的自动配置在配置文件为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSource</span><br></code></pre></td></tr></table></figure><p>在matchIfMissing为false时，如果name值为空，则返回false；如果name不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true，否则返回false。返回false也就意味着自动配置不会生效。</p><p>但是如果看HttpEncodingAutoConfiguration类上的属性配置发现并没有完全按照上面所说的name和havingValue配合使用。它是通过“prefix+value”作为属性的名称来进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.http.encoding.enabled=true</span><br></code></pre></td></tr></table></figure><p>其中prefix指定了配置的统一前缀“spring.http.encoding”，而value指定了具体的属性名称为“enabled”。这里并没有设置havingValue的值，如果havingValue未指定值，默认情况下在属性配置中设置的值为true则生效（如上配置），false则不生效。</p><p>原文链接：《<a href="https://segmentfault.com/a/1190000021236948">SPRING BOOT中@CONDITIONALONPROPERTY使用详解</a>》</p>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus updateById 不更新null字段</title>
    <link href="/2023/09/02/mybatis-plus-null-field-not-be-update/"/>
    <url>/2023/09/02/mybatis-plus-null-field-not-be-update/</url>
    
    <content type="html"><![CDATA[<h4 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h4><p>使用这两个方法，不会对实体中值为Null的属性（字段）进行更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.updateById(entity);<br> <br><span class="hljs-built_in">this</span>.update(entity, updateWrapper);<br></code></pre></td></tr></table></figure><h4 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h4><p>原因：mybatis-plus的fieldStrategy的策略有三种，分别是IGNORED-0-忽略，NOT_NULL-1-非NULL（默认策略），NOT_EMPTY-2-非空，所以造成不更新的原因是默认策略。</p><h4 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h4><ul><li>设置全局的 updateStrategy</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">dbConfig:</span><br>      <span class="hljs-attr">insertStrategy:</span> <span class="hljs-string">NOT_NULL</span><br>      <span class="hljs-attr">updateStrategy:</span> <span class="hljs-string">IGNORED</span><br>      <span class="hljs-attr">where-strategy:</span> <span class="hljs-string">NOT_NULL</span><br></code></pre></td></tr></table></figure><ul><li>对字段单独设置策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(updateStrategy= FieldStrategy.IGNORED)</span><br></code></pre></td></tr></table></figure><ul><li>使用mapper的update</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">LambdaUpdateWrapper&lt;xxx&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;&gt;();<br>wrapper.eq(xxx::getId, xxx.getId());<br>wrapper.set(xxx::getOrgUri, xxx.getOrgUri());<br>wrapper.set(xxx::getBeginTime, <span class="hljs-literal">null</span>);<br>xxxMapper.update(xxx, wrapper);<br></code></pre></td></tr></table></figure><ul><li>使用LambdaUpdateWrapper（推荐）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">LambdaUpdateWrapper&lt;BizFile&gt; lambdaUpdateWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;&gt;();<br><span class="hljs-comment">//过滤条件</span><br>lambdaUpdateWrapper.eq(BizFile::getId, bizFile.getId());<br> <br><span class="hljs-comment">//下面为设置值          </span><br><span class="hljs-comment">//由于parentId会为空，所以要使用LambdaUpdateWrapper</span><br>lambdaUpdateWrapper.set(BizFile::getParentId, parentId);<br>lambdaUpdateWrapper.set(BizFile::getPath, newDirPath);<br> <br><span class="hljs-comment">//更新</span><br><span class="hljs-built_in">this</span>.update(lambdaUpdateWrapper);<br></code></pre></td></tr></table></figure><p>第1种就免了，第2、3种验证过都可以。</p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot核心基础之spring.factories机制</title>
    <link href="/2023/08/23/spring-factories/"/>
    <url>/2023/08/23/spring-factories/</url>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在java spring cloud项目中，我们常常会在子模块中创建公共方法，那么在另外一个子模块中，需要加载配置文件的时候，往往Spring Boot 自动扫描包的时候，只会扫描自己模块下的类。这个是springboot约定俗成的内容。</p><h4 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h4><p>如果想要被Spring容器管理的Bean的路径不再Spring Boot 的包扫描路径下，怎么办呢？也就是如何去加载第三方的Bean 呢？</p><p>目前较通用的方式有2种，一是使用注解进行实例化，而是使用spring.factories机制。</p><p>这里我们使用Swagger的配置来做实验。</p><p>　首先一个Swagger的配置类：SwaggerConfig，工程结构如下：</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>发现我的SwaggerConfig 类和 SpringBoot 的启动类ConfigApplication.java 不在同一级目录下，按照springboot启动机制，以当Spring Boot 自动扫描包的时候，是扫描不到我的SwaggerConfig 的配置的，也就在控制台没有Swagger的打印的信息：</p><p><img src="/images/pasted-24.png" alt="upload successful"></p><p>所以这时候我如果想要把SwaggerConfig 加载到Spring容器中的话 要怎么办呢？下面介绍上面提到的2种方式:</p><h5 id="方法解决"><a href="#方法解决" class="headerlink" title="方法解决"></a>方法解决</h5><ul><li>方法一：在Spring Boot Application 主类上使用@Import注解。</li></ul><p><img src="/images/pasted-25.png" alt="upload successful"></p><ul><li>方法二：创建spring.factories文件<br>现在我们将其改造一下，采用spring.factories 的方式去加载SwaggerConfig类，在resources目录下新建一个META-INF 的目录，然后在</li></ul><p>新建一个spring.factories 的文件，里面的内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"># Auto Configure<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>com.sg.config.Swagger2Config<br></code></pre></td></tr></table></figure><p>然后在把Spring Boot 启动类上的@Import注释掉，启动发现也可以把SwaggerConfig加载到Spring 容器中。</p><p>到这就完成了加载一个Spring 不能扫描到的一个类，他可以是第三方的，也可以是自己写的，只要是Spring Boot 默认扫描路径不能够扫描到，都可以使用这种方式去加载。</p><h4 id="内部原理机制"><a href="#内部原理机制" class="headerlink" title="内部原理机制"></a>内部原理机制</h4><p>Spring.Factories这种机制实际上是仿照java中的SPI扩展机制实现的。</p><h4 id="什么是SPI-机制"><a href="#什么是SPI-机制" class="headerlink" title="什么是SPI 机制"></a>什么是SPI 机制</h4><p>SPI 的全名为 Service Provider Interface.这个是是针对厂商或者插件的。在java.util.ServiceLoader 的文档里有比较详细的介绍。</p><p>简单总结下Java SPI机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如 日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及了具体的实现类，就违反了可插拔的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</p><p>Java SPI 就是提供这样的一种机制：为某个接口寻找服务的实现的机制，有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制很重要。</p><h4 id="Spring-Boot-中的SPI-机制"><a href="#Spring-Boot-中的SPI-机制" class="headerlink" title="Spring Boot 中的SPI 机制"></a>Spring Boot 中的SPI 机制</h4><p>在Spring boot 中也有一种类似的加载机制，它在<br>META-INFO&#x2F;spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。</p><p>这种自定义的SPI 机制就是Spring Boot Starter 实现的基础。</p><h4 id="Spring-Factories实现原理"><a href="#Spring-Factories实现原理" class="headerlink" title="Spring Factories实现原理"></a>Spring Factories实现原理</h4><p>spring -core 包里定义了SpringFactoriesLoader 类，这个类实现了检索META-INF&#x2F;spring.factories文件，并获取指定接口的配置的功能。在这个类中定义了两个对外的方法：</p><p>loadFactories 根据接口类获取其实现类的实例，这个方法返回的是对象列表<br>loadFactoryNames 根据接口获取其接口类的名称，这个方法返回的是类名的列表。<br>上面两个方法的关键都是从指定的ClassLoader中获取spring.factories文件，并解析得到类名列表，具体代码如下：</p><p><img src="/images/pasted-26.png" alt="upload successful"><br>从代码中可以看到，在这个方法中会遍历整个ClassLoader 中所有Jar包下的spring.factories文件，也就是我们可以在自己jar中配置spring.factories文件，不会影响到其他地方的配置，也不回被别人的配置覆盖。</p><p>spring.factories的是通过Properties解析得到的，所以我们在写文件中的内容都是按照下面这种方式配置的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"># Auto Configure<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>com.sg.config.Swagger2Config<br></code></pre></td></tr></table></figure><p>如果一个接口希望配置多个实现类，可以用”,”分割。</p><h4 id="spring-boot包中的spring-factories文件"><a href="#spring-boot包中的spring-factories文件" class="headerlink" title="spring-boot包中的spring.factories文件"></a>spring-boot包中的spring.factories文件</h4><p>spring-boot包中的spring.factories文件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># PropertySource Loaders</span><br><span class="hljs-keyword">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment"># Run Listeners</span><br><span class="hljs-keyword">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.event.EventPublishingRunListener</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment"># Error Reporters</span><br><span class="hljs-keyword">org.springframework.boot.SpringBootExceptionReporter=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.FailureAnalyzers</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment"># Application Context Initializers</span><br><span class="hljs-keyword">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.ContextIdApplicationContextInitializer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment"># Application Listeners</span><br><span class="hljs-keyword">org.springframework.context.ApplicationListener=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.ClearCachesApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.config.ConfigFileApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment"># Environment Post Processors</span><br><span class="hljs-keyword">org.springframework.boot.env.EnvironmentPostProcessor=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment"># Failure Analyzers</span><br><span class="hljs-keyword">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.BindValidationFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.UnboundConfigurationPropertyFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyNameFailureAnalyzer,\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyValueFailureAnalyzer</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment"># FailureAnalysisReporters</span><br><span class="hljs-keyword">org.springframework.boot.diagnostics.FailureAnalysisReporter=\</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter</span><br></code></pre></td></tr></table></figure><p>在日常工作中，我们可能需要实现一些SDK 或者Sring boot starter 给别人用的时候，我们就可以使用Factories机制，Factories机制可以让SDK或者Stater的使用只需要很少或者不需要进行配置，只需要在服务中引入我们的Jar包就即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>idea使用技巧之检查未使用的类、变量、方法</title>
    <link href="/2023/08/04/find-unused-by-idea/"/>
    <url>/2023/08/04/find-unused-by-idea/</url>
    
    <content type="html"><![CDATA[<p> 来源：<a href="https://www.cnblogs.com/chuzijing/p/14591220.html">https://www.cnblogs.com/chuzijing/p/14591220.html</a></p><ul><li>选择Analyze——》Run Inspection by Name…或者使用快捷键Ctrl+Alt+Shift+I</li></ul><p><img src="/images/pasted-17.png" alt="upload successful"></p><ul><li>在弹框中输入：unused declaration</li></ul><p><img src="/images/pasted-18.png" alt="upload successful"></p><ul><li>弹框默认选择</li></ul><p><img src="/images/pasted-19.png" alt="upload successful"></p><ul><li>等待下方读条结束会自动弹出Inspection Results弹窗</li></ul><p><img src="/images/pasted-20.png" alt="upload successful"></p><ul><li>对没有用到的方法和变量提供了四种处理方法</li></ul><p><img src="/images/pasted-21.png" alt="upload successful"></p><p>四种处理方式</p><p>　　* Safe delete：删除；</p><p>　　* Comment out：注释掉；</p><p>　　* Add as Entry Point：添加为入口点；</p><p>　　* Suppress：添加注解@SuppressWarnings(“unused”)或@SuppressWarnings(“ALL”)；</p><p><img src="/images/pasted-22.png" alt="upload successful"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>无需额外注解的 SpringBoot API文档生成工具</title>
    <link href="/2023/07/31/JApiDocs/"/>
    <url>/2023/07/31/JApiDocs/</url>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>编写和维护API文档这个事情，对于后端程序员来说，是一件恼人但又不得不做的事情，我们都不喜欢写文档，但除非项目前后端代码都是自己写的，否则API文档将是前后端协作中一个不可或缺的沟通界面。</p><p>JApiDocs是一个无需额外注解、开箱即用的SpringBoot接口文档生成工具。</p><p>无图无真相，生成文档的效果如下：</p><p><img src="/images/pasted-15.png" alt="JApiDocs"></p><p>相比Swagger要写一堆注解，Spring Rest Docs需要写测试用例，才能生成API文档，JApiDocs 具有无痛集成的特点。</p><h4 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h4><p>要使得JApiDcos正确工作，你写的代码应该是像下面的样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/user/&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> listForm</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(path = &quot;list&quot;, method = &#123;RequestMethod.GET,  RequestMethod.POST&#125;  )</span><br>    <span class="hljs-keyword">public</span> ApiResult&lt;PageResult&lt;UserVO&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(UserListForm listForm)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userForm</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(path = &quot;save&quot;)</span><br>    <span class="hljs-keyword">public</span> ApiResult&lt;UserVO&gt; <span class="hljs-title function_">saveUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserForm userForm)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们给Controller类和方法加上必要的注释，给接口方法返回相关的对象类型。是的，这样JApiDocs就能解析到相关的接口信息了，就跟我们平时写的代码是差不多的，但要注意，你要通过@param来告诉JApiDocs接口的参数，但在IDE的帮助下，这个工作将是轻松愉悦的：</p><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>然后你在任意一个main入口方法执行下面的代码就可以生成文档了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DocsConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DocsConfig</span>();<br>config.setProjectPath(<span class="hljs-string">&quot;your springboot project path&quot;</span>); <span class="hljs-comment">// 项目根目录</span><br>config.setProjectName(<span class="hljs-string">&quot;ProjectName&quot;</span>); <span class="hljs-comment">// 项目名称</span><br>config.setApiVersion(<span class="hljs-string">&quot;V1.0&quot;</span>);       <span class="hljs-comment">// 声明该API的版本</span><br>config.setDocsPath(<span class="hljs-string">&quot;your api docs path&quot;</span>); <span class="hljs-comment">// 生成API 文档所在目录</span><br>config.setAutoGenerate(Boolean.TRUE);  <span class="hljs-comment">// 配置自动生成</span><br>Docs.buildHtmlDocs(config); <span class="hljs-comment">// 执行生成文档</span><br><br></code></pre></td></tr></table></figure><h4 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h4><p><a href="https://github.com/YeDaxia/JApiDocs">github仓库</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenAPI 文档 (Swagger)</title>
    <link href="/2023/07/26/OpenApi-swaager/"/>
    <url>/2023/07/26/OpenApi-swaager/</url>
    
    <content type="html"><![CDATA[<p>文章来源： <a href="http://ballcat.cn/guide/feature/openapi.html">http://ballcat.cn/guide/feature/openapi.html</a></p><h3 id="什么是-OpenAPI"><a href="#什么是-OpenAPI" class="headerlink" title="什么是 OpenAPI"></a>什么是 OpenAPI</h3><p>首先 OpenAPI 其实就是 Swagger, Swagger 规范于 2015 年 更名为 OpenAPI 规范，简称 OAS.</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><blockquote><p>由于 springfox 社区已经超过一年半的时间没有进行更新维护了，所以推荐大家使用 springdoc-openapi 来构建 swagger 文档。</p></blockquote><p>springdoc 官方文档地址：<a href="https://springdoc.org,这里摘录并翻译部分,更多使用可参看原文档./">https://springdoc.org，这里摘录并翻译部分，更多使用可参看原文档。</a></p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>引入 ui 依赖后，在 springboot 环境下，直接启动即可，无需任何额外配置</p><ul><li>spring-webmvc 环境下引入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lastedVersion&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>spring-webflux 环境下引入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-webflux-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lastedVersion&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这将自动将 swagger-ui 部署到 spring-boot 应用程序：</p><ul><li>文档将以 HTML 格式提供，使用官方 swagger-ui jars</li><li>启动项目后，访问 <a href="http://server:port/context-path/swagger-ui.html">http://server:port/context-path/swagger-ui.html</a> 即可进入 Swagger UI 页面，OpenAPI 描述将在以下 json 格式的 url 中 提供：<a href="http://server:port/context-path/v3/api-docs">http://server:port/context-path/v3/api-docs</a></li><li>server：域名 或 IP</li><li>port：服务器端口</li><li>port：服务器端口</li><li>文档也可以 yaml 格式提供，位于以下路径：&#x2F;v3&#x2F;api-docs.yaml</li></ul><h3 id="替换-UI"><a href="#替换-UI" class="headerlink" title="替换 UI"></a>替换 UI</h3><p>如果嫌弃官方提供的 swagger-ui 不美观，或者使用不顺手，可以选择关闭 ui，还可以剔除掉 ui 相关的 webjar 的引入。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">springdoc:</span><br>  <span class="hljs-attr">swagger-ui:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>OpenAPI 文档信息，默认可在此 url 中获取：<a href="http://server:port/context-path/v3/api-docs。">http://server:port/context-path/v3/api-docs。</a><br>可以利用其他支持 OpenAPI 协议的工具，通过此地址，进行 API 展示，如 Apifox。<br>（ Postman 的 api 测试也可以利用此地址进行导入生成 ）</p><h3 id="Javadoc-支持"><a href="#Javadoc-支持" class="headerlink" title="Javadoc 支持"></a>Javadoc 支持</h3><p>springdoc-openapi 目前支持将 javadoc 转换为 swagger 信息来源的能力，而无需用户在项目中添加对应的 Swagger 的注解。</p><p>对于想要启用 javadoc 支持的项目，在之前的依赖之外，还需要额外添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-javadoc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lastedVersion&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此依赖项改进了对 javadoc 标记和注释的支持：</p><ul><li>方法的 javadoc 注释：解析为 @Operation 描述</li><li>@return : 解析为 @Operation 响应描述</li><li>属性的 javadoc 注释：被解析为此字段的 @Schema 描述。<br>javadoc 支持基于 therapi-runtime-javadoc，所以需要开启了对应的注解处理器，否则不会生效<br>在 maven-compiler-plugin 添加对应的注解处理器:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.therapi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>therapi-runtime-javadoc-scribe<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>新版Maven，构建速度大幅提升</title>
    <link href="/2023/07/22/mvnd/"/>
    <url>/2023/07/22/mvnd/</url>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>众所周知，Maven和Gradle几乎包含了所有Java项目的构建。而目前绝大部分的Java项目都是使用Maven的方式，Maven对比Gradle的劣势很明显，就是太慢了！<br>但是现在，Maven也可以变得更快了！</p><h5 id="maven-mvnd是什么？"><a href="#maven-mvnd是什么？" class="headerlink" title="maven-mvnd是什么？"></a>maven-mvnd是什么？</h5><p>maven-mvnd是Apache Maven团队借鉴了Gradle和Takari的优点，衍生出来的更快的构建工具，maven的强化版！</p><p>maven-mvnd 在设计上，使用一个或多个守护进程来构建服务，以此来达到并行的目的！同时，maven-mvnd 内置了maven，因此我可以在maven 过渡到 maven-mvnd的过程中实现 无缝切换！不必再安装maven或进行复杂的配置更改。</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>mvnd 与 maven 命令几乎没有任何不同，可以通过查看mvnd -help 查看</p><p>举个例子、如要打包安装，则把 mvn clean install 替换为 mvnd clean install 即可。</p><h5 id="配置使用原先已存在的-maven-的仓库！"><a href="#配置使用原先已存在的-maven-的仓库！" class="headerlink" title="配置使用原先已存在的 maven 的仓库！"></a>配置使用原先已存在的 maven 的仓库！</h5><p>可以修改 mvnd 解压目录下 conf 里的 mvnd.properties 文件，<br>拉到最后面，放开 maven.setting 注释，把值改成自己的maven仓库地址即可，如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">maven.settings=D:<span class="hljs-regexp">//m</span>aven<span class="hljs-regexp">//</span>apache-maven-<span class="hljs-number">3.6</span>.<span class="hljs-number">3</span><span class="hljs-regexp">//</span>conf<span class="hljs-regexp">//</span>settings.xml<br></code></pre></td></tr></table></figure><p>到此配置已经完成 ！</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringAOP底层原理</title>
    <link href="/2022/12/14/spring-aop-01/"/>
    <url>/2022/12/14/spring-aop-01/</url>
    
    <content type="html"><![CDATA[<h4 id="理解Spring-AOP"><a href="#理解Spring-AOP" class="headerlink" title="理解Spring AOP"></a>理解Spring AOP</h4><hr><p>提到AOP那我们自然会想到初学java时经常提到的OOP，OOP表示的是面向对象编程，是一种编程思想。AOP则是面向切面编程，同样也是一种编程思想。从Spring作为一个框架的角度来说，提供了一整套的面向切面编程的机制，让我们更容易进行开发，这套机制在Spring中就称为Spring AOP。</p><p><strong>AOP</strong> ：将程序中的交叉业务（日志、安全、事务等），封装成一个切面，然后注入到目标对象的具体逻辑中去。AOP可以对某个对象或某些对象的功能进行增强，具体来说，对某个对象的方法进行增强，可以在执行方法之余额外做一些事情，可以在方法前、方法后等。</p><h4 id="Spring-AOP中的概念"><a href="#Spring-AOP中的概念" class="headerlink" title="Spring AOP中的概念"></a>Spring AOP中的概念</h4><hr><ul><li><p><strong>Aspect</strong>：切面，比如被@Aspect注解的类就是切面，可以在切面中去定义Pointcut、advice等等</p></li><li><p><strong>Join point</strong>：连接点，表示一个程序在执行过程中的一个点，比如一个方法的运行，比如一个异常的处理。在Spring AOP中，一个连接点通常表示一个方法的执行。</p></li><li><p><strong>Advice</strong>：通知，表示在一个特定连接点上所采取的动作。</p></li><li><p><strong>Pointcut</strong>：切点，用来匹配一个或多个连接点，Advice与切点表达式时关联在一起的，Advice将会执行在和切点表达式所匹配的连接点上</p></li><li><p><strong>Introduction</strong>：可以使用@DeclareParents来给所匹配的类添加一个接口，并指定一个默认实现</p></li><li><p><strong>Target object</strong>：目标对象，被代理对象</p></li><li><p><strong>AOP proxy</strong>：代理工厂，用来创建代理对象的。在Spring Framework中，要么是JDK动态代理，要么是CGLIB代理</p></li><li><p><strong>Weaving</strong>：织入，表示创建代理对象的动作，这个动作Aspejctij发生在编译时期，Spring AOP在运行时</p></li></ul><h4 id="实现方式（动态代理）"><a href="#实现方式（动态代理）" class="headerlink" title="实现方式（动态代理）"></a>实现方式（动态代理）</h4><hr><h6 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h6><p>Spring AOP 解析切面源码入口 @EnableAspectJAutoProxy —&gt; AspectJAutoProxyRegistrar —&gt;AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);通过上面的注册一个Bean定义 AnnotationAwareAspectJAutoProxyCreator.class查看注册的bean的结构，可以知道注册的是一个bean的后置处理器；此处就是ioc的一个扩展点。</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>接下来我们重点看几个重要的类</p><h5 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h5><hr><p>这个就是应用代理技术，Spring经过封装后，生成的代理工厂类，会由它来负责创建具体的代理类。</p><p><img src="/images/pasted-14.png" alt="upload successful"></p><p>通过ProxyFactory，我们在使用过程中不需要去关注到底使用cglib，还是jdk动态代理，Spring实现的PorxyFactory会帮助我们去判断通过何种方式生成代理类</p><ul><li><p>如果被代理类实现了接口，那么底层就会自动使用jdk动态代理，生成对应接口类型的代理对象</p></li><li><p>如果被代理类没有实现接口，那么就选择cglib技术</p></li><li><p>动态代理模式：动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。</p></li></ul><p><strong>说明链接</strong>： <a href="https://mp.weixin.qq.com/s/yr4Syf1bgm3fx-HiyTW2Cg">一文搞懂Spring AOP原理，面试不再怕的！</a></p><h5 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h5><hr><p>五个注解，表示代理逻辑以及执行时机</p><ul><li><p>@Before：接口MethodBeforeAdvice，继承了接口BeforeAdvice</p></li><li><p>@AfterReturning：接口AfterReturningAdvice</p></li><li><p>@AfterThrowing：接口ThrowsAdvice</p></li><li><p>@After：接口AfterAdvice</p></li><li><p>@Around：接口AfterAdvice</p></li></ul><p>Spring会把五个注解解析为对应的Advice类：  </p><ul><li><p>@Before：AspectJMethodBeforeAdvice，实际上就是一个MethodBeforeAdvice</p></li><li><p>@AfterReturning：AspectJAfterReturningAdvice，实际上就是一个AfterReturningAdvice</p></li><li><p>@AfterThrowing：AspectJAfterThrowingAdvice，实际上就是一个MethodInterceptor</p></li><li><p>@After：AspectJAfterAdvice，实际上就是一个MethodInterceptor</p></li><li><p>@Around：AspectJAroundAdvice，实际上就是一个MethodInterceptor</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4 个 yyds 的 IDEA 高级调试技巧</title>
    <link href="/2022/03/26/idea-debug-4-skills/"/>
    <url>/2022/03/26/idea-debug-4-skills/</url>
    
    <content type="html"><![CDATA[<p>今天给大家带来几个我日常工作以及阅读源码必备的 IntelliJ IDEA 高级调试技巧，分分钟要起飞的节奏</p><h4 id="断点处添加-log"><a href="#断点处添加-log" class="headerlink" title="断点处添加 log"></a>断点处添加 log</h4><p>很多程序员在调试代码时都喜欢 print 一些内容，这样看起来更直观，print 完之后又很容易忘记删除掉这些没用的内容，最终将代码提交到 remote，code review 时又不得不删减这些内容重新提交，不但增加不必要的工作量，还让 log tree 的一些节点没有任何价值</p><p>IntelliJ IDEA 提供 Evaluate and Log at Breakpoints 功能恰巧可以帮助我们解决这个问题, 来看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">ThreadLocalRandom</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>   <span class="hljs-keyword">if</span> (isInterested(random.nextInt(<span class="hljs-number">10</span>))) &#123;<br>    count++;<br>   &#125;<br>  &#125;<br>  System.out.printf(<span class="hljs-string">&quot;Found %d interested values%n&quot;</span>, count);<br> &#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterested</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>  <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><span id="more"></span><p>假如我们想在第 15 行查看每次调用，随即出来的 i 的值到底是多少，我们没必要在这个地方添加任何 log，在正常加断点的地方使用快捷键 <strong>Shift + 鼠标左键</strong>，就会弹出下面的内容</p><p><img src="/images/pasted-5.png" alt="image1"><br>勾选上 Evaluate and log, 并自定义你想查看的 log&#x2F;变量，比如这里的 “interested” + i, 这样以 Debug 模式运行程序（正常模式运行，不会打印这些 log）：</p><pre><code class="hljs">Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 6Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 0Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 9Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 8Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 1Found 3 interested valuesDisconnected from the target VM, address: &#39;127.0.0.1:0&#39;, transport: &#39;socket&#39;Process finished with exit code</code></pre><p>如果你想要更详细的信息，那就勾选上 Stack trace (大家自己查看运行结果吧)，有了这个功能，上面说的一些问题都不复存在了</p><h4 id="字段断点"><a href="#字段断点" class="headerlink" title="字段断点"></a>字段断点</h4><p>如果你阅读源码，你一定会有个困扰，类中的某个字段的值到底是在哪里改变的，你要一点点追踪调用栈，逐步排查，稍不留神，就可能有遗漏,我们可以在 IntelliJ IDEA 中为某个字段添加断点，当字段值有修改时，自动跳到相应方法位置</p><p>使用起来很简单：</p><ul><li>在字段定义处鼠标左键添加断点（会出现「眼睛」的图标）</li><li>在「眼睛」图标上鼠标右键</li><li>在弹框中勾选上 Field access 和 Field modification 两个选项<br><img src="/images/pasted-6.png" alt="upload successful"></li></ul><p>如果修改字段值的方法比较多，也可以在 Condition 的地方定义断点进入条件, 有了这个功能的加成，相信你阅读源码会顺畅许多</p><h4 id="异常断点"><a href="#异常断点" class="headerlink" title="异常断点"></a>异常断点</h4><p>除了阅读源码，一定是遇到了异常我们才开始调试代码，代码在抛出异常之后会自动停止，但是我们希望：代码停在抛出异常之前，方便我们查看当时的变量信息</p><p>这时我们就用到了 Exception Breakpoints, 当抛出异常时，在 catch 的地方打上断点，可以通过下图的几个位置获取栈顶异常类型，比如这里的 NumberFormatException</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>知道异常类型后，就可以按照如下步骤添加异常断点了：</p><p><img src="/images/pasted-8.png" alt="upload successful"><br>然后在弹框中选择 NumberFormatException</p><p><img src="/images/pasted-9.png" alt="upload successful"><br>重新以 Debug 模式运行程序：</p><p><img src="/images/pasted-10.png" alt="upload successful"><br>程序「一路绿灯式」定位到抛出异常的位置，同时指出当时的变量信息，三个字：稳，准，狠，还有谁？</p><h4 id="方法断点"><a href="#方法断点" class="headerlink" title="方法断点"></a>方法断点</h4><p>当阅读源码时，比如 Spring，一个接口的方法可能被多个子类实现，当运行时，需要查看调用栈逐步定位实现类，IDEA 同样支持在接口方法上添加断点（<strong>快捷键 cmd+F8&#x2F;ctrl+F8</strong>）：</p><ul><li>鼠标左键在方法处点击断点（♦️形状）</li><li>断点上鼠标右键</li></ul><p>勾选上绿色框线上的内容，同样可以自定义跳转条件 Condition</p><p><img src="/images/pasted-11.png" alt="upload successful"><br>当以 Debug 模式运行程序的时候，会自动进入实现类的方法（注意断点形状）：</p><p><img src="/images/pasted-12.png" alt="upload successful"><br>看到这你应该想到常见的 Runnable 接口中的 run 方法了，同样是有作用的，大家可以自行去尝试了</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>相信有以上四种调试技巧的加成，无论是工作debug 还是私下阅读源码，都可以轻松驾驭了。<br>最后，来看看 IDEA 支持的各种断点调试类型，如果你只知道红色小圆点，那咱在留言区好好说说吧</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA通过oshi获取系统和硬件信息</title>
    <link href="/2022/03/18/oshi-sample/"/>
    <url>/2022/03/18/oshi-sample/</url>
    
    <content type="html"><![CDATA[<h5 id="一、引入jar包"><a href="#一、引入jar包" class="headerlink" title="一、引入jar包"></a>一、引入jar包</h5><p>　　本项目主要使用第开源jar包：<a href="https://github.com/oshi/oshi">https://github.com/oshi/oshi</a><br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.oshi/oshi-core --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.oshi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>oshi-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><span id="more"></span><h5 id="二、测试代码"><a href="#二、测试代码" class="headerlink" title="二、测试代码"></a>二、测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> oshi.SystemInfo;<br><span class="hljs-keyword">import</span> oshi.hardware.*;<br><span class="hljs-keyword">import</span> oshi.hardware.CentralProcessor.TickType;<br><span class="hljs-keyword">import</span> oshi.software.os.*;<br><span class="hljs-keyword">import</span> oshi.software.os.OperatingSystem.ProcessSort;<br><span class="hljs-keyword">import</span> oshi.util.FormatUtil;<br><span class="hljs-keyword">import</span> oshi.util.Util;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The Class SystemInfoTest.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> dblock[at]dblock[dot]org</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemInfoTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The main method.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args the arguments</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Options: ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE</span><br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SystemInfoTest.class);<br><br>        LOG.info(<span class="hljs-string">&quot;Initializing System...&quot;</span>);<br>        <span class="hljs-type">SystemInfo</span> <span class="hljs-variable">si</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemInfo</span>();<br><br>        <span class="hljs-type">HardwareAbstractionLayer</span> <span class="hljs-variable">hal</span> <span class="hljs-operator">=</span> si.getHardware();<br>        <span class="hljs-type">OperatingSystem</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> si.getOperatingSystem();<br><br>        System.out.println(os);<br><br>        LOG.info(<span class="hljs-string">&quot;Checking computer system...&quot;</span>);<br>        printComputerSystem(hal.getComputerSystem());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Processor...&quot;</span>);<br>        printProcessor(hal.getProcessor());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Memory...&quot;</span>);<br>        printMemory(hal.getMemory());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking CPU...&quot;</span>);<br>        printCpu(hal.getProcessor());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Processes...&quot;</span>);<br>        printProcesses(os, hal.getMemory());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Sensors...&quot;</span>);<br>        printSensors(hal.getSensors());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Power sources...&quot;</span>);<br>        printPowerSources(hal.getPowerSources());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Disks...&quot;</span>);<br>        printDisks(hal.getDiskStores());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking File System...&quot;</span>);<br>        printFileSystem(os.getFileSystem());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Network interfaces...&quot;</span>);<br>        printNetworkInterfaces(hal.getNetworkIFs());<br><br>        LOG.info(<span class="hljs-string">&quot;Checking Network parameterss...&quot;</span>);<br>        printNetworkParameters(os.getNetworkParams());<br><br>        <span class="hljs-comment">// hardware: displays</span><br>        LOG.info(<span class="hljs-string">&quot;Checking Displays...&quot;</span>);<br>        printDisplays(hal.getDisplays());<br><br>        <span class="hljs-comment">// hardware: USB devices</span><br>        LOG.info(<span class="hljs-string">&quot;Checking USB Devices...&quot;</span>);<br>        printUsbDevices(hal.getUsbDevices(<span class="hljs-literal">true</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printComputerSystem</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ComputerSystem computerSystem)</span> &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;manufacturer: &quot;</span> + computerSystem.getManufacturer());<br>        System.out.println(<span class="hljs-string">&quot;model: &quot;</span> + computerSystem.getModel());<br>        System.out.println(<span class="hljs-string">&quot;serialnumber: &quot;</span> + computerSystem.getSerialNumber());<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Firmware</span> <span class="hljs-variable">firmware</span> <span class="hljs-operator">=</span> computerSystem.getFirmware();<br>        System.out.println(<span class="hljs-string">&quot;firmware:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;  manufacturer: &quot;</span> + firmware.getManufacturer());<br>        System.out.println(<span class="hljs-string">&quot;  name: &quot;</span> + firmware.getName());<br>        System.out.println(<span class="hljs-string">&quot;  description: &quot;</span> + firmware.getDescription());<br>        System.out.println(<span class="hljs-string">&quot;  version: &quot;</span> + firmware.getVersion());<br>        System.out.println(<span class="hljs-string">&quot;  release date: &quot;</span> + (firmware.getReleaseDate() == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;unknown&quot;</span><br>                : firmware.getReleaseDate() == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;unknown&quot;</span> : FormatUtil.formatDate(firmware.getReleaseDate())));<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Baseboard</span> <span class="hljs-variable">baseboard</span> <span class="hljs-operator">=</span> computerSystem.getBaseboard();<br>        System.out.println(<span class="hljs-string">&quot;baseboard:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;  manufacturer: &quot;</span> + baseboard.getManufacturer());<br>        System.out.println(<span class="hljs-string">&quot;  model: &quot;</span> + baseboard.getModel());<br>        System.out.println(<span class="hljs-string">&quot;  version: &quot;</span> + baseboard.getVersion());<br>        System.out.println(<span class="hljs-string">&quot;  serialnumber: &quot;</span> + baseboard.getSerialNumber());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printProcessor</span><span class="hljs-params">(CentralProcessor processor)</span> &#123;<br>        System.out.println(processor);<br>        System.out.println(<span class="hljs-string">&quot; &quot;</span> + processor.getPhysicalPackageCount() + <span class="hljs-string">&quot; physical CPU package(s)&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot; &quot;</span> + processor.getPhysicalProcessorCount() + <span class="hljs-string">&quot; physical CPU core(s)&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot; &quot;</span> + processor.getLogicalProcessorCount() + <span class="hljs-string">&quot; logical CPU(s)&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;Identifier: &quot;</span> + processor.getIdentifier());<br>        System.out.println(<span class="hljs-string">&quot;ProcessorID: &quot;</span> + processor.getProcessorID());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMemory</span><span class="hljs-params">(GlobalMemory memory)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Memory: &quot;</span> + FormatUtil.formatBytes(memory.getAvailable()) + <span class="hljs-string">&quot;/&quot;</span><br>                + FormatUtil.formatBytes(memory.getTotal()));<br>        System.out.println(<span class="hljs-string">&quot;Swap used: &quot;</span> + FormatUtil.formatBytes(memory.getSwapUsed()) + <span class="hljs-string">&quot;/&quot;</span><br>                + FormatUtil.formatBytes(memory.getSwapTotal()));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCpu</span><span class="hljs-params">(CentralProcessor processor)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Uptime: &quot;</span> + FormatUtil.formatElapsedSecs(processor.getSystemUptime()));<br>        System.out.println(<br>                <span class="hljs-string">&quot;Context Switches/Interrupts: &quot;</span> + processor.getContextSwitches() + <span class="hljs-string">&quot; / &quot;</span> + processor.getInterrupts());<br><br>        <span class="hljs-type">long</span>[] prevTicks = processor.getSystemCpuLoadTicks();<br>        System.out.println(<span class="hljs-string">&quot;CPU, IOWait, and IRQ ticks @ 0 sec:&quot;</span> + Arrays.toString(prevTicks));<br>        <span class="hljs-comment">// Wait a second...</span><br>        Util.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">long</span>[] ticks = processor.getSystemCpuLoadTicks();<br>        System.out.println(<span class="hljs-string">&quot;CPU, IOWait, and IRQ ticks @ 1 sec:&quot;</span> + Arrays.toString(ticks));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> ticks[TickType.USER.getIndex()] - prevTicks[TickType.USER.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nice</span> <span class="hljs-operator">=</span> ticks[TickType.NICE.getIndex()] - prevTicks[TickType.NICE.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sys</span> <span class="hljs-operator">=</span> ticks[TickType.SYSTEM.getIndex()] - prevTicks[TickType.SYSTEM.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">idle</span> <span class="hljs-operator">=</span> ticks[TickType.IDLE.getIndex()] - prevTicks[TickType.IDLE.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">iowait</span> <span class="hljs-operator">=</span> ticks[TickType.IOWAIT.getIndex()] - prevTicks[TickType.IOWAIT.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">irq</span> <span class="hljs-operator">=</span> ticks[TickType.IRQ.getIndex()] - prevTicks[TickType.IRQ.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">softirq</span> <span class="hljs-operator">=</span> ticks[TickType.SOFTIRQ.getIndex()] - prevTicks[TickType.SOFTIRQ.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">steal</span> <span class="hljs-operator">=</span> ticks[TickType.STEAL.getIndex()] - prevTicks[TickType.STEAL.getIndex()];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">totalCpu</span> <span class="hljs-operator">=</span> user + nice + sys + idle + iowait + irq + softirq + steal;<br><br>        System.out.format(<br>                <span class="hljs-string">&quot;User: %.1f%% Nice: %.1f%% System: %.1f%% Idle: %.1f%% IOwait: %.1f%% IRQ: %.1f%% SoftIRQ: %.1f%% Steal: %.1f%%%n&quot;</span>,<br>                <span class="hljs-number">100d</span> * user / totalCpu, <span class="hljs-number">100d</span> * nice / totalCpu, <span class="hljs-number">100d</span> * sys / totalCpu, <span class="hljs-number">100d</span> * idle / totalCpu,<br>                <span class="hljs-number">100d</span> * iowait / totalCpu, <span class="hljs-number">100d</span> * irq / totalCpu, <span class="hljs-number">100d</span> * softirq / totalCpu, <span class="hljs-number">100d</span> * steal / totalCpu);<br>        System.out.format(<span class="hljs-string">&quot;CPU load: %.1f%% (counting ticks)%n&quot;</span>, processor.getSystemCpuLoadBetweenTicks() * <span class="hljs-number">100</span>);<br>        System.out.format(<span class="hljs-string">&quot;CPU load: %.1f%% (OS MXBean)%n&quot;</span>, processor.getSystemCpuLoad() * <span class="hljs-number">100</span>);<br>        <span class="hljs-type">double</span>[] loadAverage = processor.getSystemLoadAverage(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;CPU load averages:&quot;</span> + (loadAverage[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot; N/A&quot;</span> : String.format(<span class="hljs-string">&quot; %.2f&quot;</span>, loadAverage[<span class="hljs-number">0</span>]))<br>                + (loadAverage[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot; N/A&quot;</span> : String.format(<span class="hljs-string">&quot; %.2f&quot;</span>, loadAverage[<span class="hljs-number">1</span>]))<br>                + (loadAverage[<span class="hljs-number">2</span>] &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot; N/A&quot;</span> : String.format(<span class="hljs-string">&quot; %.2f&quot;</span>, loadAverage[<span class="hljs-number">2</span>])));<br>        <span class="hljs-comment">// per core CPU</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">procCpu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;CPU load per processor:&quot;</span>);<br>        <span class="hljs-type">double</span>[] load = processor.getProcessorCpuLoadBetweenTicks();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> avg : load) &#123;<br>            procCpu.append(String.format(<span class="hljs-string">&quot; %.1f%%&quot;</span>, avg * <span class="hljs-number">100</span>));<br>        &#125;<br>        System.out.println(procCpu.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printProcesses</span><span class="hljs-params">(OperatingSystem os, GlobalMemory memory)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Processes: &quot;</span> + os.getProcessCount() + <span class="hljs-string">&quot;, Threads: &quot;</span> + os.getThreadCount());<br>        <span class="hljs-comment">// Sort by highest CPU</span><br>        List&lt;OSProcess&gt; procs = Arrays.asList(os.getProcesses(<span class="hljs-number">5</span>, ProcessSort.CPU));<br><br>        System.out.println(<span class="hljs-string">&quot;   PID  %CPU %MEM       VSZ       RSS Name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; procs.size() &amp;&amp; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">OSProcess</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> procs.get(i);<br>            System.out.format(<span class="hljs-string">&quot; %5d %5.1f %4.1f %9s %9s %s%n&quot;</span>, p.getProcessID(),<br>                    <span class="hljs-number">100d</span> * (p.getKernelTime() + p.getUserTime()) / p.getUpTime(),<br>                    <span class="hljs-number">100d</span> * p.getResidentSetSize() / memory.getTotal(), FormatUtil.formatBytes(p.getVirtualSize()),<br>                    FormatUtil.formatBytes(p.getResidentSetSize()), p.getName());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printSensors</span><span class="hljs-params">(Sensors sensors)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Sensors:&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot; CPU Temperature: %.1f°C%n&quot;</span>, sensors.getCpuTemperature());<br>        System.out.println(<span class="hljs-string">&quot; Fan Speeds: &quot;</span> + Arrays.toString(sensors.getFanSpeeds()));<br>        System.out.format(<span class="hljs-string">&quot; CPU Voltage: %.1fV%n&quot;</span>, sensors.getCpuVoltage());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPowerSources</span><span class="hljs-params">(PowerSource[] powerSources)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Power: &quot;</span>);<br>        <span class="hljs-keyword">if</span> (powerSources.length == <span class="hljs-number">0</span>) &#123;<br>            sb.append(<span class="hljs-string">&quot;Unknown&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">timeRemaining</span> <span class="hljs-operator">=</span> powerSources[<span class="hljs-number">0</span>].getTimeRemaining();<br>            <span class="hljs-keyword">if</span> (timeRemaining &lt; -<span class="hljs-number">1d</span>) &#123;<br>                sb.append(<span class="hljs-string">&quot;Charging&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeRemaining &lt; <span class="hljs-number">0d</span>) &#123;<br>                sb.append(<span class="hljs-string">&quot;Calculating time remaining&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(String.format(<span class="hljs-string">&quot;%d:%02d remaining&quot;</span>, (<span class="hljs-type">int</span>) (timeRemaining / <span class="hljs-number">3600</span>),<br>                        (<span class="hljs-type">int</span>) (timeRemaining / <span class="hljs-number">60</span>) % <span class="hljs-number">60</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (PowerSource pSource : powerSources) &#123;<br>            sb.append(String.format(<span class="hljs-string">&quot;%n %s @ %.1f%%&quot;</span>, pSource.getName(), pSource.getRemainingCapacity() * <span class="hljs-number">100d</span>));<br>        &#125;<br>        System.out.println(sb.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDisks</span><span class="hljs-params">(HWDiskStore[] diskStores)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Disks:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (HWDiskStore disk : diskStores) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">readwrite</span> <span class="hljs-operator">=</span> disk.getReads() &gt; <span class="hljs-number">0</span> || disk.getWrites() &gt; <span class="hljs-number">0</span>;<br>            System.out.format(<span class="hljs-string">&quot; %s: (model: %s - S/N: %s) size: %s, reads: %s (%s), writes: %s (%s), xfer: %s ms%n&quot;</span>,<br>                    disk.getName(), disk.getModel(), disk.getSerial(),<br>                    disk.getSize() &gt; <span class="hljs-number">0</span> ? FormatUtil.formatBytesDecimal(disk.getSize()) : <span class="hljs-string">&quot;?&quot;</span>,<br>                    readwrite ? disk.getReads() : <span class="hljs-string">&quot;?&quot;</span>, readwrite ? FormatUtil.formatBytes(disk.getReadBytes()) : <span class="hljs-string">&quot;?&quot;</span>,<br>                    readwrite ? disk.getWrites() : <span class="hljs-string">&quot;?&quot;</span>, readwrite ? FormatUtil.formatBytes(disk.getWriteBytes()) : <span class="hljs-string">&quot;?&quot;</span>,<br>                    readwrite ? disk.getTransferTime() : <span class="hljs-string">&quot;?&quot;</span>);<br>            HWPartition[] partitions = disk.getPartitions();<br>            <span class="hljs-keyword">if</span> (partitions == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// TODO Remove when all OS&#x27;s implemented</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (HWPartition part : partitions) &#123;<br>                System.out.format(<span class="hljs-string">&quot; |-- %s: %s (%s) Maj:Min=%d:%d, size: %s%s%n&quot;</span>, part.getIdentification(),<br>                        part.getName(), part.getType(), part.getMajor(), part.getMinor(),<br>                        FormatUtil.formatBytesDecimal(part.getSize()),<br>                        part.getMountPoint().isEmpty() ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot; @ &quot;</span> + part.getMountPoint());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printFileSystem</span><span class="hljs-params">(FileSystem fileSystem)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;File System:&quot;</span>);<br><br>        System.out.format(<span class="hljs-string">&quot; File Descriptors: %d/%d%n&quot;</span>, fileSystem.getOpenFileDescriptors(),<br>                fileSystem.getMaxFileDescriptors());<br><br>        OSFileStore[] fsArray = fileSystem.getFileStores();<br>        <span class="hljs-keyword">for</span> (OSFileStore fs : fsArray) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">usable</span> <span class="hljs-operator">=</span> fs.getUsableSpace();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> fs.getTotalSpace();<br>            System.out.format(<br>                    <span class="hljs-string">&quot; %s (%s) [%s] %s of %s free (%.1f%%) is %s &quot;</span><br>                            + (fs.getLogicalVolume() != <span class="hljs-literal">null</span> &amp;&amp; fs.getLogicalVolume().length() &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;[%s]&quot;</span> : <span class="hljs-string">&quot;%s&quot;</span>)<br>                            + <span class="hljs-string">&quot; and is mounted at %s%n&quot;</span>,<br>                    fs.getName(), fs.getDescription().isEmpty() ? <span class="hljs-string">&quot;file system&quot;</span> : fs.getDescription(), fs.getType(),<br>                    FormatUtil.formatBytes(usable), FormatUtil.formatBytes(fs.getTotalSpace()), <span class="hljs-number">100d</span> * usable / total,<br>                    fs.getVolume(), fs.getLogicalVolume(), fs.getMount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNetworkInterfaces</span><span class="hljs-params">(NetworkIF[] networkIFs)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Network interfaces:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (NetworkIF net : networkIFs) &#123;<br>            System.out.format(<span class="hljs-string">&quot; Name: %s (%s)%n&quot;</span>, net.getName(), net.getDisplayName());<br>            System.out.format(<span class="hljs-string">&quot;   MAC Address: %s %n&quot;</span>, net.getMacaddr());<br>            System.out.format(<span class="hljs-string">&quot;   MTU: %s, Speed: %s %n&quot;</span>, net.getMTU(), FormatUtil.formatValue(net.getSpeed(), <span class="hljs-string">&quot;bps&quot;</span>));<br>            System.out.format(<span class="hljs-string">&quot;   IPv4: %s %n&quot;</span>, Arrays.toString(net.getIPv4addr()));<br>            System.out.format(<span class="hljs-string">&quot;   IPv6: %s %n&quot;</span>, Arrays.toString(net.getIPv6addr()));<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">hasData</span> <span class="hljs-operator">=</span> net.getBytesRecv() &gt; <span class="hljs-number">0</span> || net.getBytesSent() &gt; <span class="hljs-number">0</span> || net.getPacketsRecv() &gt; <span class="hljs-number">0</span><br>                    || net.getPacketsSent() &gt; <span class="hljs-number">0</span>;<br>            System.out.format(<span class="hljs-string">&quot;   Traffic: received %s/%s%s; transmitted %s/%s%s %n&quot;</span>,<br>                    hasData ? net.getPacketsRecv() + <span class="hljs-string">&quot; packets&quot;</span> : <span class="hljs-string">&quot;?&quot;</span>,<br>                    hasData ? FormatUtil.formatBytes(net.getBytesRecv()) : <span class="hljs-string">&quot;?&quot;</span>,<br>                    hasData ? <span class="hljs-string">&quot; (&quot;</span> + net.getInErrors() + <span class="hljs-string">&quot; err)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                    hasData ? net.getPacketsSent() + <span class="hljs-string">&quot; packets&quot;</span> : <span class="hljs-string">&quot;?&quot;</span>,<br>                    hasData ? FormatUtil.formatBytes(net.getBytesSent()) : <span class="hljs-string">&quot;?&quot;</span>,<br>                    hasData ? <span class="hljs-string">&quot; (&quot;</span> + net.getOutErrors() + <span class="hljs-string">&quot; err)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNetworkParameters</span><span class="hljs-params">(NetworkParams networkParams)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Network parameters:&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot; Host name: %s%n&quot;</span>, networkParams.getHostName());<br>        System.out.format(<span class="hljs-string">&quot; Domain name: %s%n&quot;</span>, networkParams.getDomainName());<br>        System.out.format(<span class="hljs-string">&quot; DNS servers: %s%n&quot;</span>, Arrays.toString(networkParams.getDnsServers()));<br>        System.out.format(<span class="hljs-string">&quot; IPv4 Gateway: %s%n&quot;</span>, networkParams.getIpv4DefaultGateway());<br>        System.out.format(<span class="hljs-string">&quot; IPv6 Gateway: %s%n&quot;</span>, networkParams.getIpv6DefaultGateway());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDisplays</span><span class="hljs-params">(Display[] displays)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Displays:&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Display display : displays) &#123;<br>            System.out.println(<span class="hljs-string">&quot; Display &quot;</span> + i + <span class="hljs-string">&quot;:&quot;</span>);<br>            System.out.println(display.toString());<br>            i++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printUsbDevices</span><span class="hljs-params">(UsbDevice[] usbDevices)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;USB Devices:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (UsbDevice usbDevice : usbDevices) &#123;<br>            System.out.println(usbDevice.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Microsoft</span> <span class="hljs-string">Windows</span> <span class="hljs-number">10</span> <span class="hljs-string">build</span> <span class="hljs-number">15063</span><br><span class="hljs-attr">manufacturer:</span> <span class="hljs-string">LENOVO</span><br><span class="hljs-attr">model:</span> <span class="hljs-string">80RU</span><br><span class="hljs-attr">serialnumber:</span> <span class="hljs-string">R90LN08UR9N0B6922009</span><br><span class="hljs-attr">firmware:</span><br>  <span class="hljs-attr">manufacturer:</span> <span class="hljs-string">LENOVO</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">E5CN53WW</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">E5CN53WW</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">LENOVO</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">release date:</span> <span class="hljs-number">07</span><span class="hljs-string">/11/2016</span><br><span class="hljs-attr">baseboard:</span><br>  <span class="hljs-attr">manufacturer:</span> <span class="hljs-string">LENOVO</span><br>  <span class="hljs-attr">model:</span> <span class="hljs-string">unknown</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">SDK0K09938</span> <span class="hljs-string">WIN</span><br>  <span class="hljs-attr">serialnumber:</span> <span class="hljs-string">R90LN08U</span><br><span class="hljs-string">Intel(R)</span> <span class="hljs-string">Core(TM)</span> <span class="hljs-string">i5-6300HQ</span> <span class="hljs-string">CPU</span> <span class="hljs-string">@</span> <span class="hljs-number">2.</span><span class="hljs-string">30GHz</span><br> <span class="hljs-number">1</span> <span class="hljs-string">physical</span> <span class="hljs-string">CPU</span> <span class="hljs-string">package(s)</span><br> <span class="hljs-number">4</span> <span class="hljs-string">physical</span> <span class="hljs-string">CPU</span> <span class="hljs-string">core(s)</span><br> <span class="hljs-number">4</span> <span class="hljs-string">logical</span> <span class="hljs-string">CPU(s)</span><br><span class="hljs-attr">Identifier:</span> <span class="hljs-string">Intel64</span> <span class="hljs-string">Family</span> <span class="hljs-number">6</span> <span class="hljs-string">Model</span> <span class="hljs-number">94</span> <span class="hljs-string">Stepping</span> <span class="hljs-number">3</span><br><span class="hljs-attr">ProcessorID:</span> <span class="hljs-string">BFEBFBFF000506E3</span><br><span class="hljs-attr">Memory:</span> <span class="hljs-number">1.5</span> <span class="hljs-string">GiB/7.8</span> <span class="hljs-string">GiB</span><br><span class="hljs-attr">Swap used:</span> <span class="hljs-number">84.4</span> <span class="hljs-string">MiB/6.3</span> <span class="hljs-string">GiB</span><br><span class="hljs-attr">Uptime:</span> <span class="hljs-number">1</span> <span class="hljs-string">days,</span> <span class="hljs-number">11</span><span class="hljs-string">:45:25</span><br><span class="hljs-attr">Context Switches/Interrupts:</span> <span class="hljs-number">648525190</span> <span class="hljs-string">/</span> <span class="hljs-number">338012494</span><br><span class="hljs-string">CPU,</span> <span class="hljs-string">IOWait,</span> <span class="hljs-string">and</span> <span class="hljs-string">IRQ</span> <span class="hljs-string">ticks</span> <span class="hljs-string">@</span> <span class="hljs-number">0</span> <span class="hljs-string">sec:[18421421,</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-number">10068431</span><span class="hljs-string">,</span> <span class="hljs-number">288934828</span><span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-number">266351</span><span class="hljs-string">,</span> <span class="hljs-number">143296</span><span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">]</span><br><span class="hljs-string">CPU,</span> <span class="hljs-string">IOWait,</span> <span class="hljs-string">and</span> <span class="hljs-string">IRQ</span> <span class="hljs-string">ticks</span> <span class="hljs-string">@</span> <span class="hljs-number">1</span> <span class="hljs-string">sec:[18421578,</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-number">10068486</span><span class="hljs-string">,</span> <span class="hljs-number">288938671</span><span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-number">266351</span><span class="hljs-string">,</span> <span class="hljs-number">143304</span><span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">]</span><br><span class="hljs-attr">User:</span> <span class="hljs-number">3.9</span><span class="hljs-string">%</span> <span class="hljs-attr">Nice:</span> <span class="hljs-number">0.0</span><span class="hljs-string">%</span> <span class="hljs-attr">System:</span> <span class="hljs-number">1.4</span><span class="hljs-string">%</span> <span class="hljs-attr">Idle:</span> <span class="hljs-number">94.6</span><span class="hljs-string">%</span> <span class="hljs-attr">IOwait:</span> <span class="hljs-number">0.0</span><span class="hljs-string">%</span> <span class="hljs-attr">IRQ:</span> <span class="hljs-number">0.0</span><span class="hljs-string">%</span> <span class="hljs-attr">SoftIRQ:</span> <span class="hljs-number">0.2</span><span class="hljs-string">%</span> <span class="hljs-attr">Steal:</span> <span class="hljs-number">0.0</span><span class="hljs-string">%</span><br><span class="hljs-attr">CPU load:</span> <span class="hljs-number">13.0</span><span class="hljs-string">%</span> <span class="hljs-string">(counting</span> <span class="hljs-string">ticks)</span><br><span class="hljs-attr">CPU load:</span> <span class="hljs-number">17.4</span><span class="hljs-string">%</span> <span class="hljs-string">(OS</span> <span class="hljs-string">MXBean)</span><br><span class="hljs-attr">CPU load averages:</span> <span class="hljs-string">N/A</span> <span class="hljs-string">N/A</span> <span class="hljs-string">N/A</span><br><span class="hljs-attr">CPU load per processor:</span> <span class="hljs-number">19.3</span><span class="hljs-string">%</span> <span class="hljs-number">12.8</span><span class="hljs-string">%</span> <span class="hljs-number">12.8</span><span class="hljs-string">%</span> <span class="hljs-number">12.8</span><span class="hljs-string">%</span><br><span class="hljs-attr">Processes:</span> <span class="hljs-number">184</span><span class="hljs-string">,</span> <span class="hljs-attr">Threads:</span> <span class="hljs-number">2447</span><br>   <span class="hljs-string">PID</span>  <span class="hljs-string">%CPU</span> <span class="hljs-string">%MEM</span>       <span class="hljs-string">VSZ</span>       <span class="hljs-string">RSS</span> <span class="hljs-string">Name</span><br>     <span class="hljs-number">0</span> <span class="hljs-number">100.0</span>  <span class="hljs-number">0.0</span>    <span class="hljs-number">64</span> <span class="hljs-string">KiB</span>     <span class="hljs-number">8</span> <span class="hljs-string">KiB</span> <span class="hljs-string">System</span> <span class="hljs-string">Idle</span> <span class="hljs-string">Process</span><br>  <span class="hljs-number">5416  </span><span class="hljs-number">10.0</span>  <span class="hljs-number">1.6</span>   <span class="hljs-number">3.4</span> <span class="hljs-string">GiB</span> <span class="hljs-number">130.4</span> <span class="hljs-string">MiB</span> <span class="hljs-string">java.exe</span><br> <span class="hljs-number">12676</span>   <span class="hljs-number">8.8</span>  <span class="hljs-number">1.3</span>   <span class="hljs-number">2.1</span> <span class="hljs-string">GiB</span> <span class="hljs-number">104.9</span> <span class="hljs-string">MiB</span> <span class="hljs-string">java.exe</span><br> <span class="hljs-number">11988</span>   <span class="hljs-number">5.8</span> <span class="hljs-number">16.8</span>   <span class="hljs-number">3.3</span> <span class="hljs-string">GiB</span>   <span class="hljs-number">1.3</span> <span class="hljs-string">GiB</span> <span class="hljs-string">idea64.exe</span><br>  <span class="hljs-number">5312   </span><span class="hljs-number">4.4</span>  <span class="hljs-number">1.3</span>   <span class="hljs-number">2.0</span> <span class="hljs-string">TiB</span> <span class="hljs-number">101.4</span> <span class="hljs-string">MiB</span> <span class="hljs-string">chrome.exe</span><br><span class="hljs-attr">Sensors:</span><br> <span class="hljs-attr">CPU Temperature:</span> <span class="hljs-number">42.0</span><span class="hljs-string">°C</span><br> <span class="hljs-attr">Fan Speeds:</span> [<span class="hljs-number">0</span>]<br> <span class="hljs-attr">CPU Voltage:</span> <span class="hljs-number">0.</span><span class="hljs-string">0V</span><br><span class="hljs-attr">Power:</span> <span class="hljs-string">Charging</span><br> <span class="hljs-string">System</span> <span class="hljs-string">Battery</span> <span class="hljs-string">@</span> <span class="hljs-number">96.6</span><span class="hljs-string">%</span><br><span class="hljs-attr">Disks:</span><br> <span class="hljs-string">\\.\PHYSICALDRIVE0:</span> <span class="hljs-string">(model:</span> <span class="hljs-string">SanDisk</span> <span class="hljs-string">SD7SN6S128G</span> <span class="hljs-string">(标准磁盘驱动器)</span> <span class="hljs-bullet">-</span> <span class="hljs-attr">S/N:</span> <span class="hljs-number">161416401094</span><span class="hljs-string">)</span> <span class="hljs-attr">size:</span> <span class="hljs-number">128.0</span> <span class="hljs-string">GB,</span> <span class="hljs-attr">reads:</span> <span class="hljs-number">1117123</span> <span class="hljs-string">(33.4</span> <span class="hljs-string">GiB),</span> <span class="hljs-attr">writes:</span> <span class="hljs-number">703948</span> <span class="hljs-string">(21.2</span> <span class="hljs-string">GiB),</span> <span class="hljs-attr">xfer:</span> <span class="hljs-number">2570354</span> <span class="hljs-string">ms</span><br> <span class="hljs-string">|--</span> <span class="hljs-string">磁盘</span> <span class="hljs-comment">#0，分区 #0: GPT: Basic Data (GPT: 基本数据) Maj:Min=0:0, size: 471.9 MB @ F:\</span><br> <span class="hljs-string">|--</span> <span class="hljs-string">磁盘</span> <span class="hljs-comment">#0，分区 #1: GPT: System (GPT: 系统) Maj:Min=0:1, size: 104.9 MB</span><br> <span class="hljs-string">|--</span> <span class="hljs-string">磁盘</span> <span class="hljs-comment">#0，分区 #2: GPT: Basic Data (GPT: 基本数据) Maj:Min=0:2, size: 126.6 GB @ C:\</span><br> <span class="hljs-string">|--</span> <span class="hljs-string">磁盘</span> <span class="hljs-comment">#0，分区 #3: GPT: Basic Data (GPT: 基本数据) Maj:Min=0:3, size: 845.2 MB @ G:\</span><br> <span class="hljs-string">\\.\PHYSICALDRIVE1:</span> <span class="hljs-string">(model:</span> <span class="hljs-string">WDC</span> <span class="hljs-string">WD10SPCX-24HWST1</span> <span class="hljs-string">(标准磁盘驱动器)</span> <span class="hljs-bullet">-</span> <span class="hljs-attr">S/N:</span>      <span class="hljs-string">WD-WX31A86F35XC)</span> <span class="hljs-attr">size:</span> <span class="hljs-number">1.0</span> <span class="hljs-string">TB,</span> <span class="hljs-attr">reads:</span> <span class="hljs-number">379263</span> <span class="hljs-string">(6.0</span> <span class="hljs-string">GiB),</span> <span class="hljs-attr">writes:</span> <span class="hljs-number">103105</span> <span class="hljs-string">(2.6</span> <span class="hljs-string">GiB),</span> <span class="hljs-attr">xfer:</span> <span class="hljs-number">4014792</span> <span class="hljs-string">ms</span><br> <span class="hljs-string">|--</span> <span class="hljs-string">磁盘</span> <span class="hljs-comment">#1，分区 #0: GPT: Basic Data (GPT: 基本数据) Maj:Min=1:0, size: 475.9 GB @ D:\</span><br> <span class="hljs-string">|--</span> <span class="hljs-string">磁盘</span> <span class="hljs-comment">#1，分区 #1: GPT: Basic Data (GPT: 基本数据) Maj:Min=1:1, size: 524.3 GB @ E:\</span><br><span class="hljs-attr">File System:</span><br> <span class="hljs-attr">File Descriptors:</span> <span class="hljs-number">0</span><span class="hljs-string">/0</span><br> <span class="hljs-string">本地固定磁盘</span> <span class="hljs-string">(F:)</span> <span class="hljs-string">(Fixed</span> <span class="hljs-string">drive)</span> [<span class="hljs-string">NTFS</span>] <span class="hljs-number">436.1</span> <span class="hljs-string">MiB</span> <span class="hljs-string">of</span> <span class="hljs-number">450.0</span> <span class="hljs-string">MiB</span> <span class="hljs-string">free</span> <span class="hljs-string">(96.9%)</span> <span class="hljs-string">is</span> <span class="hljs-string">\\?\Volume&#123;9afc85a4-9f44-11e7-ab77-a5dc01376557&#125;\</span>  <span class="hljs-string">and</span> <span class="hljs-string">is</span> <span class="hljs-string">mounted</span> <span class="hljs-string">at</span> <span class="hljs-string">F:\</span><br> <span class="hljs-string">本地固定磁盘</span> <span class="hljs-string">(C:)</span> <span class="hljs-string">(Fixed</span> <span class="hljs-string">drive)</span> [<span class="hljs-string">NTFS</span>] <span class="hljs-number">12.9</span> <span class="hljs-string">GiB</span> <span class="hljs-string">of</span> <span class="hljs-number">117.9</span> <span class="hljs-string">GiB</span> <span class="hljs-string">free</span> <span class="hljs-string">(11.0%)</span> <span class="hljs-string">is</span> <span class="hljs-string">\\?\Volume&#123;01a1a160-fbb4-49c7-be19-6dd52882bcbc&#125;\</span>  <span class="hljs-string">and</span> <span class="hljs-string">is</span> <span class="hljs-string">mounted</span> <span class="hljs-string">at</span> <span class="hljs-string">C:\</span><br> <span class="hljs-string">本地固定磁盘</span> <span class="hljs-string">(G:)</span> <span class="hljs-string">(Fixed</span> <span class="hljs-string">drive)</span> [<span class="hljs-string">NTFS</span>] <span class="hljs-number">303.4</span> <span class="hljs-string">MiB</span> <span class="hljs-string">of</span> <span class="hljs-number">806.0</span> <span class="hljs-string">MiB</span> <span class="hljs-string">free</span> <span class="hljs-string">(37.6%)</span> <span class="hljs-string">is</span> <span class="hljs-string">\\?\Volume&#123;9afc85a5-9f44-11e7-ab77-a5dc01376557&#125;\</span>  <span class="hljs-string">and</span> <span class="hljs-string">is</span> <span class="hljs-string">mounted</span> <span class="hljs-string">at</span> <span class="hljs-string">G:\</span><br> <span class="hljs-string">本地固定磁盘</span> <span class="hljs-string">(D:)</span> <span class="hljs-string">(Fixed</span> <span class="hljs-string">drive)</span> [<span class="hljs-string">NTFS</span>] <span class="hljs-number">161.8</span> <span class="hljs-string">GiB</span> <span class="hljs-string">of</span> <span class="hljs-number">443.2</span> <span class="hljs-string">GiB</span> <span class="hljs-string">free</span> <span class="hljs-string">(36.5%)</span> <span class="hljs-string">is</span> <span class="hljs-string">\\?\Volume&#123;a287f045-a9ac-4669-ab44-bdbd74692600&#125;\</span>  <span class="hljs-string">and</span> <span class="hljs-string">is</span> <span class="hljs-string">mounted</span> <span class="hljs-string">at</span> <span class="hljs-string">D:\</span><br> <span class="hljs-string">本地固定磁盘</span> <span class="hljs-string">(E:)</span> <span class="hljs-string">(Fixed</span> <span class="hljs-string">drive)</span> [<span class="hljs-string">NTFS</span>] <span class="hljs-number">246.0</span> <span class="hljs-string">GiB</span> <span class="hljs-string">of</span> <span class="hljs-number">488.3</span> <span class="hljs-string">GiB</span> <span class="hljs-string">free</span> <span class="hljs-string">(50.4%)</span> <span class="hljs-string">is</span> <span class="hljs-string">\\?\Volume&#123;84c6da35-38e7-457e-b528-c12da6ed2898&#125;\</span>  <span class="hljs-string">and</span> <span class="hljs-string">is</span> <span class="hljs-string">mounted</span> <span class="hljs-string">at</span> <span class="hljs-string">E:\</span><br><span class="hljs-attr">Network interfaces:</span><br> <span class="hljs-attr">Name:</span> <span class="hljs-string">wlan0</span> <span class="hljs-string">(Microsoft</span> <span class="hljs-string">Wi-Fi</span> <span class="hljs-string">Direct</span> <span class="hljs-string">Virtual</span> <span class="hljs-string">Adapter)</span><br>   <span class="hljs-attr">MAC Address:</span> <span class="hljs-number">84</span><span class="hljs-string">:ef:18:36:4c:ab</span> <br>   <span class="hljs-attr">MTU:</span> <span class="hljs-number">1500</span><span class="hljs-string">,</span> <span class="hljs-attr">Speed:</span> <span class="hljs-number">0</span> <span class="hljs-string">bps</span> <br>   <span class="hljs-attr">IPv4:</span> [] <br>   <span class="hljs-attr">IPv6:</span> [<span class="hljs-string">fe80:0:0:0:55ed:790e:b70:ea43</span>] <br>   <span class="hljs-attr">Traffic:</span> <span class="hljs-string">received</span> <span class="hljs-string">?/?;</span> <span class="hljs-string">transmitted</span> <span class="hljs-string">?/?</span> <br> <span class="hljs-attr">Name:</span> <span class="hljs-string">net2</span> <span class="hljs-string">(Microsoft</span> <span class="hljs-string">Teredo</span> <span class="hljs-string">Tunneling</span> <span class="hljs-string">Adapter)</span><br>   <span class="hljs-attr">MAC Address:</span> <span class="hljs-number">00</span><span class="hljs-string">:00:00:00:00:00:00:e0</span> <br>   <span class="hljs-attr">MTU:</span> <span class="hljs-number">1280</span><span class="hljs-string">,</span> <span class="hljs-attr">Speed:</span> <span class="hljs-number">100</span> <span class="hljs-string">Kbps</span> <br>   <span class="hljs-attr">IPv4:</span> [] <br>   <span class="hljs-attr">IPv6:</span> [<span class="hljs-number">2001</span><span class="hljs-string">:0:9d38:6ab8:2446:2d3f:34a2:86f5</span>, <span class="hljs-string">fe80:0:0:0:2446:2d3f:34a2:86f5</span>] <br>   <span class="hljs-attr">Traffic:</span> <span class="hljs-string">received</span> <span class="hljs-number">15</span> <span class="hljs-string">packets/2.2</span> <span class="hljs-string">KiB</span> <span class="hljs-string">(0</span> <span class="hljs-string">err);</span> <span class="hljs-string">transmitted</span> <span class="hljs-number">1580 </span><span class="hljs-string">packets/209.9</span> <span class="hljs-string">KiB</span> <span class="hljs-string">(0</span> <span class="hljs-string">err)</span> <br> <span class="hljs-attr">Name:</span> <span class="hljs-string">eth7</span> <span class="hljs-string">(Realtek</span> <span class="hljs-string">PCIe</span> <span class="hljs-string">GBE</span> <span class="hljs-string">Family</span> <span class="hljs-string">Controller)</span><br>   <span class="hljs-attr">MAC Address:</span> <span class="hljs-number">54</span><span class="hljs-string">:ee:75:b0:ed:33</span> <br>   <span class="hljs-attr">MTU:</span> <span class="hljs-number">1500</span><span class="hljs-string">,</span> <span class="hljs-attr">Speed:</span> <span class="hljs-number">0</span> <span class="hljs-string">bps</span> <br>   <span class="hljs-attr">IPv4:</span> [] <br>   <span class="hljs-attr">IPv6:</span> [<span class="hljs-string">fe80:0:0:0:d0:cff0:250f:34d0</span>] <br>   <span class="hljs-attr">Traffic:</span> <span class="hljs-string">received</span> <span class="hljs-string">?/?;</span> <span class="hljs-string">transmitted</span> <span class="hljs-string">?/?</span> <br> <span class="hljs-attr">Name:</span> <span class="hljs-string">wlan2</span> <span class="hljs-string">(Intel(R)</span> <span class="hljs-string">Dual</span> <span class="hljs-string">Band</span> <span class="hljs-string">Wireless-AC</span> <span class="hljs-number">3165</span><span class="hljs-string">)</span><br>   <span class="hljs-attr">MAC Address:</span> <span class="hljs-number">84</span><span class="hljs-string">:ef:18:36:4c:aa</span> <br>   <span class="hljs-attr">MTU:</span> <span class="hljs-number">1500</span><span class="hljs-string">,</span> <span class="hljs-attr">Speed:</span> <span class="hljs-number">72.2</span> <span class="hljs-string">Mbps</span> <br>   <span class="hljs-attr">IPv4:</span> [<span class="hljs-number">172.16</span><span class="hljs-number">.3</span><span class="hljs-number">.132</span>] <br>   <span class="hljs-attr">IPv6:</span> [] <br>   <span class="hljs-attr">Traffic:</span> <span class="hljs-string">received</span> <span class="hljs-number">99670</span> <span class="hljs-string">packets/87.7</span> <span class="hljs-string">MiB</span> <span class="hljs-string">(0</span> <span class="hljs-string">err);</span> <span class="hljs-string">transmitted</span> <span class="hljs-number">68049</span> <span class="hljs-string">packets/14.9</span> <span class="hljs-string">MiB</span> <span class="hljs-string">(0</span> <span class="hljs-string">err)</span> <br><span class="hljs-attr">Network parameters:</span><br> <span class="hljs-attr">Host name:</span> <span class="hljs-string">Sindrol-NTB</span><br> <span class="hljs-attr">Domain name:</span> <span class="hljs-string">Sindrol-NTB</span><br> <span class="hljs-attr">DNS servers:</span> [<span class="hljs-number">202.106</span><span class="hljs-number">.0</span><span class="hljs-number">.20</span>, <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>]<br> <span class="hljs-attr">IPv4 Gateway:</span> <span class="hljs-number">172.16</span><span class="hljs-number">.3</span><span class="hljs-number">.254</span><br> <span class="hljs-attr">IPv6 Gateway: ::</span><br><span class="hljs-attr">Displays:</span><br> <span class="hljs-attr">Display 0:</span><br>  <span class="hljs-string">Manuf.</span> <span class="hljs-string">ID=BOE,</span> <span class="hljs-string">Product</span> <span class="hljs-string">ID=65d,</span> <span class="hljs-string">Digital,</span> <span class="hljs-string">Serial=00000000,</span> <span class="hljs-string">ManufDate=1/2015,</span> <span class="hljs-string">EDID</span> <span class="hljs-string">v1.4</span><br>  <span class="hljs-number">34</span> <span class="hljs-string">x</span> <span class="hljs-number">19</span> <span class="hljs-string">cm</span> <span class="hljs-string">(13.4</span> <span class="hljs-string">x</span> <span class="hljs-number">7.5</span> <span class="hljs-string">in)</span><br>  <span class="hljs-attr">Preferred Timing:</span> <span class="hljs-string">Clock</span> <span class="hljs-string">141MHz,</span> <span class="hljs-string">Active</span> <span class="hljs-string">Pixels</span> <span class="hljs-string">1920x1080</span> <br>  <span class="hljs-attr">Manufacturer Data:</span> <span class="hljs-number">000000000000000000000000000000000000</span><br>  <span class="hljs-attr">Unspecified Text:</span> <span class="hljs-string">BOE</span> <span class="hljs-string">HF</span><br>  <span class="hljs-attr">Unspecified Text:</span> <span class="hljs-string">NV156FHM-N42</span><br> <span class="hljs-attr">Display 1:</span><br>  <span class="hljs-string">Manuf.</span> <span class="hljs-string">ID=AOC,</span> <span class="hljs-string">Product</span> <span class="hljs-string">ID=2476,</span> <span class="hljs-string">Digital,</span> <span class="hljs-string">Serial=00000319,</span> <span class="hljs-string">ManufDate=5/2016,</span> <span class="hljs-string">EDID</span> <span class="hljs-string">v1.3</span><br>  <span class="hljs-number">52</span> <span class="hljs-string">x</span> <span class="hljs-number">29</span> <span class="hljs-string">cm</span> <span class="hljs-string">(20.5</span> <span class="hljs-string">x</span> <span class="hljs-number">11.4</span> <span class="hljs-string">in)</span><br>  <span class="hljs-attr">Preferred Timing:</span> <span class="hljs-string">Clock</span> <span class="hljs-string">148MHz,</span> <span class="hljs-string">Active</span> <span class="hljs-string">Pixels</span> <span class="hljs-string">1920x1080</span> <br>  <span class="hljs-attr">Range Limits:</span> <span class="hljs-string">Field</span> <span class="hljs-string">Rate</span> <span class="hljs-number">50</span><span class="hljs-number">-76</span> <span class="hljs-string">Hz</span> <span class="hljs-string">vertical,</span> <span class="hljs-number">30</span><span class="hljs-number">-83</span> <span class="hljs-string">Hz</span> <span class="hljs-string">horizontal,</span> <span class="hljs-attr">Max clock:</span> <span class="hljs-number">170</span> <span class="hljs-string">MHz</span><br>  <span class="hljs-attr">Monitor Name:</span> <span class="hljs-string">2476WM</span><br>  <span class="hljs-attr">Serial Number:</span> <span class="hljs-string">E71G5BA000793</span><br><span class="hljs-attr">USB Devices:</span><br> <span class="hljs-string">Intel(R)</span> <span class="hljs-string">USB</span> <span class="hljs-number">3.0</span> <span class="hljs-string">可扩展主机控制器</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1.0</span> <span class="hljs-string">(Microsoft)</span> <span class="hljs-string">(通用</span> <span class="hljs-string">USB</span> <span class="hljs-string">xHCI</span> <span class="hljs-string">主机控制器)</span><br> <span class="hljs-string">|--</span> <span class="hljs-string">USB</span> <span class="hljs-string">根集线器(USB</span> <span class="hljs-number">3.0</span><span class="hljs-string">)</span> <span class="hljs-string">((标准</span> <span class="hljs-string">USB</span> <span class="hljs-string">集线器))</span><br>     <span class="hljs-string">|--</span> <span class="hljs-string">Apple</span> <span class="hljs-string">Mobile</span> <span class="hljs-string">Device</span> <span class="hljs-string">USB</span> <span class="hljs-string">Driver</span> <span class="hljs-string">(Apple,</span> <span class="hljs-string">Inc.)</span><br>         <span class="hljs-string">|--</span> <span class="hljs-string">Apple</span> <span class="hljs-string">iPhone</span> <span class="hljs-string">(Apple</span> <span class="hljs-string">Inc.)</span><br>     <span class="hljs-string">|--</span> <span class="hljs-string">USB</span> <span class="hljs-string">Composite</span> <span class="hljs-string">Device</span> <span class="hljs-string">((标准</span> <span class="hljs-string">USB</span> <span class="hljs-string">主控制器))</span><br>         <span class="hljs-string">|--</span> <span class="hljs-string">Lenovo</span> <span class="hljs-string">EasyCamera</span> <span class="hljs-string">(Bison)</span><br>     <span class="hljs-string">|--</span> <span class="hljs-string">USB</span> <span class="hljs-string">Composite</span> <span class="hljs-string">Device</span> <span class="hljs-string">((标准</span> <span class="hljs-string">USB</span> <span class="hljs-string">主控制器))</span><br>         <span class="hljs-string">|--</span> <span class="hljs-string">USB</span> <span class="hljs-string">输入设备</span> <span class="hljs-string">((标准系统设备))</span><br>             <span class="hljs-string">|--</span> <span class="hljs-string">HID</span> <span class="hljs-string">Keyboard</span> <span class="hljs-string">Device</span> <span class="hljs-string">((标准键盘))</span><br>         <span class="hljs-string">|--</span> <span class="hljs-string">USB</span> <span class="hljs-string">输入设备</span> <span class="hljs-string">((标准系统设备))</span><br>             <span class="hljs-string">|--</span> <span class="hljs-string">HID-compliant</span> <span class="hljs-string">mouse</span> <span class="hljs-string">(Microsoft)</span><br>             <span class="hljs-string">|--</span> <span class="hljs-string">符合</span> <span class="hljs-string">HID</span> <span class="hljs-string">标准的供应商定义设备</span> <span class="hljs-string">((标准系统设备))</span><br>             <span class="hljs-string">|--</span> <span class="hljs-string">符合</span> <span class="hljs-string">HID</span> <span class="hljs-string">标准的用户控制设备</span> <span class="hljs-string">(Microsoft)</span><br>             <span class="hljs-string">|--</span> <span class="hljs-string">符合</span> <span class="hljs-string">HID</span> <span class="hljs-string">标准的系统控制器</span> <span class="hljs-string">((标准系统设备))</span><br>         <span class="hljs-string">|--</span> <span class="hljs-string">USB</span> <span class="hljs-string">输入设备</span> <span class="hljs-string">((标准系统设备))</span><br>             <span class="hljs-string">|--</span> <span class="hljs-string">符合</span> <span class="hljs-string">HID</span> <span class="hljs-string">标准的供应商定义设备</span> <span class="hljs-string">((标准系统设备))</span><br>     <span class="hljs-string">|--</span> <span class="hljs-string">USB</span> <span class="hljs-string">输入设备</span> <span class="hljs-string">((标准系统设备))</span><br>         <span class="hljs-string">|--</span> <span class="hljs-string">HID-compliant</span> <span class="hljs-string">mouse</span> <span class="hljs-string">(Microsoft)</span><br>     <span class="hljs-string">|--</span> <span class="hljs-string">英特尔(R)</span> <span class="hljs-string">无线</span> <span class="hljs-string">Bluetooth(R)</span> <span class="hljs-string">(Intel</span> <span class="hljs-string">Corporation)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>oshi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache-Aside pattern</title>
    <link href="/2022/03/12/Cache-Aside-pattern/"/>
    <url>/2022/03/12/Cache-Aside-pattern/</url>
    
    <content type="html"><![CDATA[<p>首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出</p><ul><li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><span id="more"></span><p>另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。</p><p>这种情况不存在并发问题么？</p><p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><ul><li>缓存刚好失效</li><li>请求A查询数据库，得一个旧值</li><li>请求B将新值写入数据库</li><li>请求B删除缓存</li><li>请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。</li></ul><p>然而，发生这种情况的概率又有多少呢？</p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</p><p>假设，有人非要抬杠，有强迫症，一定要解决怎么办？</p><h5 id="如何解决上述并发问题？"><a href="#如何解决上述并发问题？" class="headerlink" title="如何解决上述并发问题？"></a>如何解决上述并发问题？</h5><p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p><h5 id="还有其他造成不一致的原因么？"><a href="#还有其他造成不一致的原因么？" class="headerlink" title="还有其他造成不一致的原因么？"></a>还有其他造成不一致的原因么？</h5><p>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p><p>如何解决？</p><p>提供一个保障的重试机制即可，这里给出两套方案。</p><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><p>如下图所示</p><p><img src="/images/pasted-1.png" alt="upload1"></p><p>流程如下所示</p><ul><li>更新数据库数据；</li><li>缓存因为种种问题删除失败</li><li>将需要删除的key发送至消息队列</li><li>自己消费消息，获得需要删除的key</li><li>继续重试删除操作，直到成功</li></ul><p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p><h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>流程如下图所示：</p><p>更新数据库数据</p><ul><li>数据库会将操作信息写入binlog日志当中</li><li>订阅程序提取出所需要的数据以及key</li><li>另起一段非业务代码，获得该信息</li><li>尝试删除缓存操作，发现删除失败</li><li>将这些信息发送至消息队列</li><li>重新从消息队列中获得该数据，重试操作。</li></ul><p> <a href="https://www.cnblogs.com/xiaoxiao1120/p/15255541.html">https://www.cnblogs.com/xiaoxiao1120/p/15255541.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安装docker</title>
    <link href="/2022/02/19/install-docker-on-linux/"/>
    <url>/2022/02/19/install-docker-on-linux/</url>
    
    <content type="html"><![CDATA[<h3 id="Ubuntu-14-04-16-04（使用-apt-get-进行安装）"><a href="#Ubuntu-14-04-16-04（使用-apt-get-进行安装）" class="headerlink" title="Ubuntu 14.04&#x2F;16.04（使用 apt-get 进行安装）"></a>Ubuntu 14.04&#x2F;16.04（使用 apt-get 进行安装）</h3><p>step 1: 安装必要的一些系统工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br></code></pre></td></tr></table></figure><span id="more"></span><p>step 2: 安装GPG证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>step 3: 写入软件源信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;<br></code></pre></td></tr></table></figure><p>step 4: 更新并安装Docker-CE</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get -y update<br>sudo apt-get -y install docker-ce<br></code></pre></td></tr></table></figure><p>安装指定版本的Docker-CE:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Step 1: 查找Docker-CE的版本:</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">apt-cache madison docker-ce</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo apt-get -y install docker-ce=[VERSION]</span><br><br></code></pre></td></tr></table></figure><h3 id="CentOS-7（使用-yum-进行安装）"><a href="#CentOS-7（使用-yum-进行安装）" class="headerlink" title="CentOS 7（使用 yum 进行安装）"></a>CentOS 7（使用 yum 进行安装）</h3><p>step 1: 安装必要的一些系统工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p>step 2: 添加软件源信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>step 3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><p>step 4: 更新并安装Docker-CE</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum makecache fast<br>sudo yum -y install docker-ce<br></code></pre></td></tr></table></figure><p>step 4: 开启Docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service docker start<br></code></pre></td></tr></table></figure><p>注意：<br>官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># vim /etc/yum.repos.d/docker-ce.repo</span><br><span class="hljs-comment">#   将[docker-ce-test]下方的enabled=0修改为enabled=1</span><br><span class="hljs-comment"># 安装指定版本的Docker-CE:</span><br><span class="hljs-attribute">step</span> <span class="hljs-number">1</span>: 查找Docker-CE的版本:<br><span class="hljs-comment"># yum list docker-ce.x86_64 --showduplicates | sort -r</span><br><span class="hljs-comment">#   Loading mirror speeds from cached hostfile</span><br><span class="hljs-comment">#   Loaded plugins: branch, fastestmirror, langpacks</span><br><span class="hljs-comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="hljs-comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span><br><span class="hljs-comment">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br><span class="hljs-comment">#   Available Packages</span><br><span class="hljs-attribute">step2</span>: 安装指定版本的Docker-CE: (VERSION例如上面的<span class="hljs-number">17</span>.<span class="hljs-number">03</span>.<span class="hljs-number">0</span>.ce.<span class="hljs-number">1</span>-<span class="hljs-number">1</span>.el7.centos)<br><span class="hljs-comment"># sudo yum -y install docker-ce-[VERSION]</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac下hostadmin修改host文件提示权限不足的问题</title>
    <link href="/2022/02/09/mac-editor-etc-hosts/"/>
    <url>/2022/02/09/mac-editor-etc-hosts/</url>
    
    <content type="html"><![CDATA[<p>修改文件写入权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod og+w /etc/hosts<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提高 GitHub 下载速度的方案</title>
    <link href="/2022/02/08/download-file-from-github/"/>
    <url>/2022/02/08/download-file-from-github/</url>
    
    <content type="html"><![CDATA[<p>GitHub 文件加速<br>利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带 CDN.</p><p><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz</a></p><p><a href="https://g.ioiox.com/">https://g.ioiox.com</a></p><p>以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub (<a href="https://hunsh.net/archives/23/">https://hunsh.net/archives/23/</a>)</p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hibernate在用注解设置字段的默认值时遇到的问题</title>
    <link href="/2022/01/04/hibernate-modify-default-value/"/>
    <url>/2022/01/04/hibernate-modify-default-value/</url>
    
    <content type="html"><![CDATA[<p>今天小编在用hibernate设置字段的默认值的时候遇到的一个小问题，特意分享一下，以免后来人继续犯错。。</p><p>小编的pojo层的代码是这样写的。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Shayla.pojo;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><br><span class="hljs-keyword">import</span> javax.persistence.Column;<br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.GenerationType;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-keyword">import</span> org.hibernate.annotations.DynamicInsert;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name=&quot;t_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>  <span class="hljs-meta">@Id</span><br>  <span class="hljs-meta">@GeneratedValue(strategy=GenerationType.AUTO)</span>    <span class="hljs-comment">//主键生成策略</span><br>  <span class="hljs-keyword">private</span> Integer id;<br>  <span class="hljs-keyword">private</span> String username;<br>  <span class="hljs-keyword">private</span> String password;<br>  <span class="hljs-keyword">private</span> String nickname;<br>  <span class="hljs-meta">@Column(nullable=false,columnDefinition=&quot;Integer default 1&quot;)</span>   <span class="hljs-comment">//这里是设置这个字段的默认值是Integer类型并且值为1</span><br>  <span class="hljs-keyword">private</span> String status;<br><span class="hljs-comment">//省略getter和setter方法。。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样在插入数据进数据库的时候是会报下面这个错误的。。。<br><img src="/images/pasted-4.png"><br>就是说，这个字段在执行hibernate生成的sql语句的时候，字段status还是空的（null），小编设置的默认值完全不管用。。0</p><p>小编在网上找到了解决的方法。。</p><p>就是往类名上面加上一个注解。。。@DynamicInsert</p><p>这个注解的作用如下（小编在网上查到一位大神的博客，截图下来的）。。<br><img src="/images/pasted-3.png"><br>这个注解的功能就是，当hibernate生成insert语句的时候会把值为null的字段过滤掉，不加入insert语句的参数中。</p><p>小编猜想，hiebernate给字段设置默认值是在hibernate生成的insert语句执行之后再生成一条insert语句，专门插入status的值。。</p><p>你们觉得呢。。。。。<br>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/LuciferMS/article/details/77803115">https://blog.csdn.net/LuciferMS/article/details/77803115</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用nacos_api实现服务注册和下线</title>
    <link href="/2020/12/11/use_nacos_api/"/>
    <url>/2020/12/11/use_nacos_api/</url>
    
    <content type="html"><![CDATA[<p>采用api注册服务和下线服务</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Nacos</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String nacosAddress;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">gameServerName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;game-server&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nacosAddress nacos服务ip端口  127.0.0.1:8848</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Nacos</span><span class="hljs-params">(String nacosAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nacosAddress = nacosAddress;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册到nacos</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip        服务地址127.0.0.1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port      服务端口 8080</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(String ip, <span class="hljs-type">int</span> port)</span> &#123;<br>        registerInstance(<span class="hljs-literal">null</span>, ip, port);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册到nacos</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName 组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip        服务地址127.0.0.1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port      服务端口 8080</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(String groupName, String ip, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取nacos服务</span><br>            <span class="hljs-type">NamingService</span> <span class="hljs-variable">namingService</span> <span class="hljs-operator">=</span> NamingFactory.createNamingService(nacosAddress);<br>            <span class="hljs-comment">//将服务注册到注册中心</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(groupName)) &#123;<br>                namingService.registerInstance(gameServerName, ip, port);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                namingService.registerInstance(gameServerName, groupName, ip, port);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            LogUtil.error(<span class="hljs-string">&quot;注册实例失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下线服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deregisterInstance</span><span class="hljs-params">(String ip, <span class="hljs-type">int</span> port)</span> &#123;<br>        registerInstance(<span class="hljs-literal">null</span>, ip, port);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下线服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deregisterInstance</span><span class="hljs-params">(String groupName, String ip, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取nacos服务</span><br>            <span class="hljs-type">NamingService</span> <span class="hljs-variable">namingService</span> <span class="hljs-operator">=</span> NamingFactory.createNamingService(nacosAddress);<br>            <span class="hljs-comment">//将服务注册到注册中心</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(groupName)) &#123;<br>                namingService.deregisterInstance(gameServerName, ip, port);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                namingService.deregisterInstance(gameServerName, groupName, ip, port);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            LogUtil.error(<span class="hljs-string">&quot;下线实例失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Instance <span class="hljs-title function_">selectOneHealthyInstance</span><span class="hljs-params">(String serviceName)</span> &#123;<br>        <span class="hljs-keyword">return</span> selectOneHealthyInstance(serviceName, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Instance <span class="hljs-title function_">selectOneHealthyInstance</span><span class="hljs-params">(String serviceName, String groupName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取nacos服务</span><br>            <span class="hljs-type">NamingService</span> <span class="hljs-variable">namingService</span> <span class="hljs-operator">=</span> NamingFactory.createNamingService(nacosAddress);<br>            <span class="hljs-comment">//将服务注册到注册中心</span><br>            Instance instance;<br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(groupName)) &#123;<br>                instance = namingService.selectOneHealthyInstance(serviceName);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                instance = namingService.selectOneHealthyInstance(serviceName, groupName);<br>            &#125;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            LogUtil.error(<span class="hljs-string">&quot;获取服务实例失败&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-cloud-stream的手动消息确认</title>
    <link href="/2020/11/26/spring-cloud-stream-ack-setting/"/>
    <url>/2020/11/26/spring-cloud-stream-ack-setting/</url>
    
    <content type="html"><![CDATA[<p>对于kafka-binder来说,设置autoCommitOffset为false.然后在listen中手动确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@StreamListener(Sink.INPUT)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-meta">@Header(KafkaHeaders.ACKNOWLEDGMENT)</span> Acknowledgment acknowledgment)</span>&#123;<br>    <span class="hljs-comment">//...业务代码</span><br>    acknowledgment.acknowledge();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是autoCommitOffset的设置位置.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.cloud.stream.kafka.bindings.input.consumer.autoCommitOffset</span>=<span class="hljs-string">false#应该在这里设置</span><br><span class="hljs-attr">spring.cloud.stream.bindings.input.consumer.autoCommitOffset</span>=<span class="hljs-string">false#这里设置是无效的,获取Acknowledgment时会是null</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>spring cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring中实现异步的四种方式</title>
    <link href="/2020/11/25/async-handle-method-in-spring/"/>
    <url>/2020/11/25/async-handle-method-in-spring/</url>
    
    <content type="html"><![CDATA[<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>对于一些比较耗时的操作.可以将他们 以 异步的方式实现. 完成后在通知调用者。  <br>Spring实现的异步方法：</p><ul><li>AsyncRestTemplate</li><li>@Async注解</li><li>WebClient(spring 5.0引入）<br>除了这三种.还有一种基于MQ消息队列的方式实现异步。<br>使用消息队列 可以在service层异步 也可以在controller层异步。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java8 对象集合按时间排序</title>
    <link href="/2020/11/19/sort-lit-by-object-time/"/>
    <url>/2020/11/19/sort-lit-by-object-time/</url>
    
    <content type="html"><![CDATA[<h4 id="java8-对象集合按时间排序"><a href="#java8-对象集合按时间排序" class="headerlink" title="java8 对象集合按时间排序"></a>java8 对象集合按时间排序</h4><p>升序  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">coDoctorVOList.sort(Comparator.comparing(CoDoctorVO::getTime));<br></code></pre></td></tr></table></figure><p>降序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">coDoctorVOList.sort((m1, m2) -&gt; m2.getTime().compareTo(m1.getTime()));<br></code></pre></td></tr></table></figure><p>ps:getTime()是对象中获取时间参数的方法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nacos 1.4 code:503,msg:server is DOWN now, please try again later! </title>
    <link href="/2020/11/17/nacos-503-error/"/>
    <url>/2020/11/17/nacos-503-error/</url>
    
    <content type="html"><![CDATA[<p>现象：<br>今天电脑更换了ip,1.4.0版本 单机模式下 重启nacos出现如下错误:<br><code> 错误：code:503,msg:server is DOWN now, please try again later!</code>  <br>原因:  <br>1.4.0使用了jraft， jraft会记录前一次启动的集群地址，如果重启机器ip变了的话，会导致jraft记录的地址失效，从而导致选主出问题。</p><p>解决方式：<br>删除{nacos.home}&#x2F;nacos&#x2F;data&#x2F;protocol文件夹后重新启动。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java面试题目文档</title>
    <link href="/2020/10/30/java-document-list/"/>
    <url>/2020/10/30/java-document-list/</url>
    
    <content type="html"><![CDATA[<p>HowToDoInJava 中文系列教程    <br><a href="http://ysocket.gitee.io/howtodoinjava-zh">http://ysocket.gitee.io/howtodoinjava-zh</a></p><p>中华石杉–互联网Java进阶面试训练营    <br><a href="https://doocs.gitee.io/advanced-java">https://doocs.gitee.io/advanced-java</a></p><p>java工程师成神之路<br><a href="http://ysocket.gitee.io/toBeTopJavaer">http://ysocket.gitee.io/toBeTopJavaer</a></p><p>Java 虚拟机底层原理知识总结<br><a href="http://ysocket.gitee.io/jvm">http://ysocket.gitee.io/jvm</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 下安装 dnsmasq 来配置开发环境</title>
    <link href="/2020/09/26/Mac-install-dnsmasq/"/>
    <url>/2020/09/26/Mac-install-dnsmasq/</url>
    
    <content type="html"><![CDATA[<p>由于实际的开发当中，可能存在多个项目的情况，如果是在本地自行搭建的坏境的话，就很有可能需要使用多个域名了，当然，也可以是 localhost &#x2F; localhost:81 &#x2F; localhost:82 这样来访问多个项目。其实，有更加便捷的方法（忽略自行修改&#x2F;etc&#x2F;hosts，这种哈，会改死人的），使用一个管理dns的工具： dnsmasq。  </p><ul><li>安装 dnsmasq</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">brew install dnsmasq<br></code></pre></td></tr></table></figure><span id="more"></span><ul><li>编辑配置文件  <br><code>vi /usr/local/etc/dnsmasq.conf</code> 修改内容:</li></ul><p> </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">resolv-file</span>=<span class="hljs-string">/usr/local/etc/resolv.dnsmasq.conf</span><br><span class="hljs-attr">addn-hosts</span>=<span class="hljs-string">/etc/dnsmasq.hosts</span><br><span class="hljs-attr">strict-order</span><br></code></pre></td></tr></table></figure><ul><li>创建文件 <code>vi /usr/local/etc/resolv.dnsmasq.conf</code>  并添加内容:</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">listen-address</span>=<span class="hljs-string">0.0.0.0</span><br><span class="hljs-attr">nameserver</span> <span class="hljs-string">114.114.114.114</span><br><span class="hljs-attr">nameserver</span> <span class="hljs-string">221.228.255.1</span><br><span class="hljs-attr">nameserver</span> <span class="hljs-string">223.5.5.5</span><br><span class="hljs-attr">nameserver</span> <span class="hljs-string">223.6.6.6</span><br></code></pre></td></tr></table></figure><ul><li>开发环境配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">vi /usr/local/etc/dnsmasq.conf<br></code></pre></td></tr></table></figure><p>修改内容: </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#dev-server</span><br><span class="hljs-attr">address</span>=/xyz.local/<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-comment">#这样的意思就是访问 *.xyz.local 直接引导到 127.0.0.1</span><br></code></pre></td></tr></table></figure><ul><li>重启dnsmasq<br><code>sudo brew services restart dnsmasq</code></li></ul><p>最后wifi的dns只要配置一个127.0.0.1即可</p><ul><li>测试</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ping abc.xyz.local<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Mac</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot多模块项目中配置国际化</title>
    <link href="/2020/08/22/springboot-multi-module-i18n/"/>
    <url>/2020/08/22/springboot-multi-module-i18n/</url>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://www.cnblogs.com/weixinya/p/12893531.html">https://www.cnblogs.com/weixinya/p/12893531.html</a></p><p>在多个module组成的SpringBoot项目中，可以为每个module单独配置属于自己的国际化资源。</p><ol><li>模块单独添加国际化配置文件<br>每个module单独配置一套配置文件；需要注意的是：配置文件basename不能出现重复，否则会出现配置文件被其他模块的同名配置文件屏蔽的情况！这里建议使用各个module的模块名作为配置文件的basename，既避免出现重复，又逻辑清晰优雅。</li><li>配置查找国际化资源路径<br>在程序入口所在包下application.yml配置文件中，配置所引用的module中的国际化路径，通过“,”来配置多个module的国际化资源文件。如下所示：<br>application.yml中多module国际化配置：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">spring:<br>  messages:<br>    <span class="hljs-built_in">basename</span>: i18n/common,i18n/publicRes,i18n/roleRight,i18n/userMsg<br>    encoding: UTF-8<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac查找指定文件类型下包含某个字符串的文件</title>
    <link href="/2020/08/21/find-file-include-same-string/"/>
    <url>/2020/08/21/find-file-include-same-string/</url>
    
    <content type="html"><![CDATA[<p>想在整个文件夹下面查找包含字符串 “getAll”并且类型是.js的文件</p><p>终端命令：<br><code>find ./ -name &quot;*.js&quot; | xargs grep &quot;getAll&quot; -l</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>brew 安装zookeeper 3.4.14</title>
    <link href="/2020/07/29/brew_install_zookeeper_3_4_14/"/>
    <url>/2020/07/29/brew_install_zookeeper_3_4_14/</url>
    
    <content type="html"><![CDATA[<p>brew 安装zookeeper 3.4.14</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># force install zookeeper first</span><br>brew install https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Homebrew/</span>homebrew-core<span class="hljs-regexp">/6d8197bbb5f77e62d51041a3ae552ce2f8ff1344/</span>Formula/zookeeper.rb<br><br><span class="hljs-comment"># then force install kafka compatible with zookeeper 3.4.14</span><br>brew install --ignore-dependencies https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Homebrew/</span>homebrew-core<span class="hljs-regexp">/6d8197bbb5f77e62d51041a3ae552ce2f8ff1344/</span>Formula/kafka.rb<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MacOS brew 安装 consul</title>
    <link href="/2020/07/28/MacOS-brew-install-consul/"/>
    <url>/2020/07/28/MacOS-brew-install-consul/</url>
    
    <content type="html"><![CDATA[<p>安装consul</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>consul<br></code></pre></td></tr></table></figure><p>配置consul：<br><code>vim /usr/local/opt/consul/homebrew.mxcl.consul.plist</code></p><p>修改 ProgramArguments 部分：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;<span class="hljs-built_in">string</span>&gt;<span class="hljs-regexp">/usr/</span>local/opt/consul/bin/consul&lt;/<span class="hljs-built_in">string</span>&gt;<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>agent<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-server<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-advertise<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>127.0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-data-dir<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>./data<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-ui<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>然后启动服务：<br><code>brew services start consul</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS zsh history命令显示操作时间</title>
    <link href="/2020/07/07/Mac-zsh-history-show-time/"/>
    <url>/2020/07/07/Mac-zsh-history-show-time/</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> -E</span><br>    1   2.12.2013 14:19  cd ..<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> -i</span><br>    1  2013-12-02 14:19  history -E<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> -D</span><br>    1  0:00  history -E<br>    2  0:00  history -I<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac GitBook安装和使用</title>
    <link href="/2020/06/20/Install-gitbook-on-mac/"/>
    <url>/2020/06/20/Install-gitbook-on-mac/</url>
    
    <content type="html"><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li>安装npm</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">brew install <span class="hljs-keyword">node</span><br> <span class="hljs-title">// 检查npm</span>是否安装成功<br> npm -v<br> // 检查<span class="hljs-keyword">node</span><span class="hljs-title">是否存在</span><br><span class="hljs-title"> node</span> -v<br></code></pre></td></tr></table></figure><ul><li>安装GitBook</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">Gitbook是在<span class="hljs-built_in">npm</span>环境下安装的，所以前提得先安装好<span class="hljs-built_in">npm</span>。<br><span class="hljs-regexp">//</span> 安装Gitbook命令<br>sudo <span class="hljs-built_in">npm</span> install -g gitbook-cli<br><span class="hljs-regexp">//</span> 检查是否安装成功<br>gitbook -v<br></code></pre></td></tr></table></figure><ul><li>安装Gitbook Editor客户端</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">官网下载地址：https:<span class="hljs-comment">//www.gitbook.com/editor</span><br>用它辅助写文档很好用，可以登录从GitBook下载Book进行修改提交（我试过直接https进行拉取出错，后来直接云端下载同步到本地才能进行<span class="hljs-built_in">push</span>操作）<br>不过没有生成静态Html（_book那个文件夹），还需cd 命令进入book所在文件使用gitbook build这条命令进行生成。<br>不过Gitbook网站里支持阅读和下载。<br></code></pre></td></tr></table></figure><ul><li>注意事项</li><li>不能使用 npm install gitbook -g 命令安装，因为使用命令gitbook的时候会出现问题。</li><li>安装的命令前需要加入sudo,因为可能会找不到npm的 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;路径。</li><li>使用gitbook -v命令检查时可能会不出现版本号，但其实是安装好了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>gitbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grep搜索子目录中包含某字符串的特定文件</title>
    <link href="/2020/06/04/grep-string-from-folder/"/>
    <url>/2020/06/04/grep-string-from-folder/</url>
    
    <content type="html"><![CDATA[<p><code>grep -n &quot;str&quot; -r ./</code></p><p>这是查找当前目录下以及下辖子目录下所有包含str字符串的文件,会列出文件名.以及该行的内容.以及行号</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 分页</title>
    <link href="/2020/05/22/mysql-page/"/>
    <url>/2020/05/22/mysql-page/</url>
    
    <content type="html"><![CDATA[<p>之前借助mysql-plus分页，由于表数据越来越大 导致分页效率越来越低</p><p>改为用id来分页，效果明显</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span><br>A.* <br><span class="hljs-keyword">FROM</span><br>time_machine_cmd A  <br><span class="hljs-keyword">JOIN</span> <br>    ( <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> time_machine_cmd <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">3000</span>, <span class="hljs-number">10</span> ) B<br>    <span class="hljs-keyword">ON</span> A.id = B.id<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何重新安装 macOS 系统</title>
    <link href="/2020/05/16/how-to-reinstall-macos/"/>
    <url>/2020/05/16/how-to-reinstall-macos/</url>
    
    <content type="html"><![CDATA[<p>大家可能都知道了，重装 macOS 系统可以在重启 Mac 时按住 <strong>⌘-R</strong> 键。</p><span id="more"></span><p>R 应该就是「Recovery」的意思</p><p>当出现「实用工具」窗口时松开，然后选择「重新安装 macOS」。<br>这样会重新安装你现在 Mac 上的 macOS 版本。</p><p>这也是我们重新安装 macOS 系统最常用的方法。但除此之外还有别的方式。</p><p><strong>option-⌘-R</strong></p><p>重启 Mac 时按住 ⌘-R 键，当看到旋转地球出现时松开。</p><p>这样会升级到与你的 Mac 兼容的最新版 macOS。</p><p><strong>shift-option-⌘-R</strong></p><p>当看到旋转地球出现时松开。</p><p>这样会开始安装你电脑出场时的那个系统版本。</p><p>举个例子可能更好理解这三种的区别：</p><p>比如假设我的全新 MacBook Pro 购买时当初是 10.12.4，现在的版本是 10.13.1，然后现在的最新版本已经是 10.14.5。</p><p>如果我用 <strong>⌘-R</strong> 来重装，得到的就是升级之前一样的 10.13 的最新版，也就是10.13.4。</p><p>如果我用 <strong>option-⌘-R</strong> 来重装，得到的就是现在官方的最新版 10.14.5。</p><p>如果我用 <strong>shift-option-⌘-R</strong> 来重装，得到的就是我当初购买时候的 10.12.4。</p><p>以上方法重新安装系统都不会删除你原来的的文件和设置。</p><p>如果你想要在重装时先格式化你的磁盘，可以在 macOS 实用工具窗口选择「磁盘工具」，然后抹掉磁盘，再执行重新安装操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 10.14.6安装 brew</title>
    <link href="/2020/05/14/install-brew-on-mac/"/>
    <url>/2020/05/14/install-brew-on-mac/</url>
    
    <content type="html"><![CDATA[<p>Mac 10.14.6安装 brew</p><p>一、获取 install 文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Homebrew/i</span>nstall<span class="hljs-regexp">/master/i</span>nstall &gt;&gt; brew_install<br></code></pre></td></tr></table></figure><span id="more"></span><p>二、更改脚本中的资源链接<br>替换<br><code>BREW_REPO = “https://github.com/Homebrew/brew“.freeze</code><br>为  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">BREW_REPO = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;.<span class="hljs-keyword">freeze</span><br></code></pre></td></tr></table></figure><p>三、运行脚本</p><p><code>/usr/bin/ruby brew_install</code></p><p>四、下载homebrew-core</p><p>到下载homebrew-core这步会失败<br>失败后运行以下命令clone git库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/git/</span>homebrew<span class="hljs-regexp">/homebrew-core.git /u</span>sr<span class="hljs-regexp">/local/</span>Homebrew<span class="hljs-regexp">/Library/</span>Taps<span class="hljs-regexp">/homebrew/</span>homebrew-core --depth=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>五、检查安装是否成功</p><p><code>brew doctor</code></p><p>六、添加清华大学镜像源</p><pre><code class="hljs">echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#39;&gt;&gt;   ~/.bash_profile</code></pre><p>使其生效<br><code>source ~/.bash_profile</code></p>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见 MySQL 的慢查询优化方式</title>
    <link href="/2020/05/13/optimize_MySQL_Slow_Query/"/>
    <url>/2020/05/13/optimize_MySQL_Slow_Query/</url>
    
    <content type="html"><![CDATA[<p>慢查询日志概念</p><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。</p><span id="more"></span><p>默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p>慢查询日志相关参数</p><p>MySQL 慢查询的相关参数解释：</p><ul><li>slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。</li><li>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</li><li>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。</li><li>log_output：日志存储方式。log_output&#x3D;’FILE’表示将日志存入文件，默认值是’FILE’。log_output&#x3D;’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output&#x3D;’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</li></ul><p>一，第一步.开启mysql慢查询<br>方式一：<br>修改配置文件  在 my.ini 增加几行:  主要是慢查询的定义时间，以及慢查询log日志记录（ slow_query_log）<br>方法二：通过MySQL数据库开启慢查询:</p><p>二，分析慢查询日志<br>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句<br>例如：执行</p><p><code>EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000</code><br>得到如下结果：显示结果分析：<br><code>table |  type | possible_keys | key |key_len  | ref | rows | Extra</code><br>EXPLAIN列的解释:</p><ul><li>table   显示这一行的数据是关于哪张表的           </li><li>type    这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL</li><li>rows   显示需要扫描行数</li><li>key     使用的索引</li></ul><p>三，常见的慢查询优化</p><p>（1）索引没起作用的情况</p><ul><li>使用LIKE关键字的查询语句<br>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</li><li>使用多列索引的查询语句<br> MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</li></ul><p>（2）优化数据库结构<br>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><ul><li>将字段很多的表分解成多个表<br>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li><li>增加中间表<br>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</li></ul><p>（3）分解关联查询<br>将一个大的查询分解为多个小查询是很有必要的。<br>很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：     </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> * FROM <span class="hljs-built_in">tag</span> <br><span class="hljs-keyword">JOIN</span> tag_post <span class="hljs-keyword">ON</span> tag_id = <span class="hljs-built_in">tag</span>.id<br><span class="hljs-keyword">JOIN</span> post <span class="hljs-keyword">ON</span> tag_post.post_id = post.id<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">tag</span>.<span class="hljs-built_in">tag</span> = <span class="hljs-string">&#x27;mysql&#x27;</span>;<br></code></pre></td></tr></table></figure><p>分解为：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tag <span class="hljs-keyword">WHERE</span> tag = <span class="hljs-string">&#x27;mysql&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tag_post <span class="hljs-keyword">WHERE</span> tag_id = <span class="hljs-number">1234</span>;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> post <span class="hljs-keyword">WHERE</span> post.id <span class="hljs-keyword">in</span> (<span class="hljs-number">123</span>,<span class="hljs-number">456</span>,<span class="hljs-number">567</span>);<br></code></pre></td></tr></table></figure><p>（4）优化LIMIT分页<br> 在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p><p> 一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p><p>优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p> 对于下面的查询：</p><p>  <code>select id,title from collect limit 90000,10;</code></p><p>该语句存在的最大问题在于limit M,N中偏移量M太大（我们暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。</p><p> 如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。试想，如我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次 查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。</p><p>方法一：虑筛选字段（title）上加索引<br>title字段加索引  （此效率如何未加验证）</p><p>方法二：先查询出主键id值<br><code>select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</code></p><p>原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</p><p>方法三：“关延迟联”<br>如果这个表非常大，那么这个查询可以改写成如下的方式：<br>  <code>select news.id, news.description from news    inner join (select id from news order by title limit 50000,5) as myNew using(id);</code></p><p>这里的“关延迟联”将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p><p>方法四：建立复合索引 acct_id和create_time<br><code>select * from acct_trans_log WHERE  acct_id = 3095  order by create_time desc limit 0,10 </code></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git merge –squash介绍</title>
    <link href="/2020/05/09/git-merge-squash/"/>
    <url>/2020/05/09/git-merge-squash/</url>
    
    <content type="html"><![CDATA[<p>Git相对于CVS和SVN的一大好处就是merge非常方便，只要指出branch的名字就好了，如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git merge another<br><span class="hljs-variable">$ </span>git checkout another<br><span class="hljs-comment"># modify, commit, modify, commit ...</span><br><span class="hljs-variable">$ </span>git checkout master<br><span class="hljs-variable">$ </span>git merge another<br></code></pre></td></tr></table></figure><span id="more"></span><p>但是，操作方便并不意味着这样操作就是合理的，在某些情况下，我们应该优先选择使用<code>--squash</code>选项，如下：</p><pre><code class="hljs">$ git merge --squash another$ git commit -m &quot;message here&quot;</code></pre><p><code>--squash</code>选项的含义是：本地文件内容与不使用该选项的合并结果相同，但是不提交、不移动HEAD，因此需要一条额外的commit命令。其效果相当于将another分支上的多个commit合并成一个，放在当前分支上，原来的commit历史则没有拿过来。</p><p>判断是否使用<code>--squash</code>选项最根本的标准是，待合并分支上的历史是否有意义。</p><p>如果在开发分支上提交非常随意，甚至写成微博体，那么一定要使用<code>--squash</code>选项。版本历史记录的应该是代码的发展，而不是开发者在编码时的活动。</p><p>只有在开发分支上每个commit都有其独自存在的意义，并且能够编译通过的情况下（能够通过测试就更完美了），才应该选择缺省的合并方式来保留commit历史。</p><p>转自：<a href="https://www.cnblogs.com/lookphp/p/5799533.html">git merge –squash介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下设置 sublime Text3 在同一个窗口打开多个文件</title>
    <link href="/2020/05/07/open-multi-file-in-sublime/"/>
    <url>/2020/05/07/open-multi-file-in-sublime/</url>
    
    <content type="html"><![CDATA[<p>打开Sublime Text软件</p><p>点击左上角的<code>Sublime Text ---&gt; Preferences ---&gt; Settings－user</code></p><p>添加 <code>&quot;open_files_in_new_window&quot;:false</code></p>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git撤销commit 并保存之前的修改</title>
    <link href="/2020/05/07/git-revert-commit-keep-modify/"/>
    <url>/2020/05/07/git-revert-commit-keep-modify/</url>
    
    <content type="html"><![CDATA[<p>写完代码后，我们一般这样<br><code>git add .</code> &#x2F;&#x2F;添加所有文件<br><code>git commit -m &quot;本功能全部完成&quot;</code></p><span id="more"></span><p>执行完commit后，想撤回commit，怎么办？</p><p>这样凉拌:</p><p><code>git reset --soft HEAD^</code></p><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><p>说一下个人理解：</p><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><p>至于这几个参数：</p><p><code>--mixed </code></p><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p><p><code>--soft </code> </p><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p><p><code>--hard</code></p><p>删除工作空间改动代码，撤销commit，撤销git add .</p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><p>顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：</p><p><code>git commit --amend</code></p><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-stash 搁置修改</title>
    <link href="/2020/04/22/git-stash/"/>
    <url>/2020/04/22/git-stash/</url>
    
    <content type="html"><![CDATA[<p>有时候写了一半的JAVA代码，都还不能编译通过的，就被叫去改另一个分支的bug了。  </p><span id="more"></span><p>在new分支上的时候在命令行输入：</p><p><code>git stash</code></p><p>或者</p><p><code>git stash save  “修改的信息&quot;</code></p><p>这样以后你的代码就回到自己上一个commit了，直接git stash的话git stash的栈会直接给你一个hash值作为版本的说明，如果用git stash save “修改的信息”，git stash的栈会把你填写的“修改的信息”作为版本的说明。</p><p>接下来你回到old分支修改代码完成，你又再回到new分支，输入：</p><p><code>git stash pop</code><br>或者<br><code>git stash list</code><br><code>git stash apply stash@&#123;0&#125;</code></p><p>就可以回到保存的版本了。</p><p><code>git stash pop</code>的作用是将<code>git stash</code>栈中最后一个版本取出来，<code>git stash apply stash@&#123;0&#125;</code>的作用是可以指定栈中的一个版本，通过<code>git stash list</code>可以看到所有的版本信息：  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">stash</span>@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-literal">On</span> order-master-bugfix: <span class="hljs-number">22222</span>   <br><span class="hljs-attribute">stash</span>@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-literal">On</span> order-master-bugfix: <span class="hljs-number">22222</span>  <br></code></pre></td></tr></table></figure><p>然后你可以选择一个你需要的版本执行：</p><p><code>git stash apply stash@&#123;0&#125;</code></p><p>这时候你搁置的代码就回来了。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8-Collectors</title>
    <link href="/2020/04/16/Collectors/"/>
    <url>/2020/04/16/Collectors/</url>
    
    <content type="html"><![CDATA[<p>在<a href="./2020/04/15/Stream-API/">第二天</a>，你已经学习了Stream API能够让你以声明式的方式帮助你处理集合。我们看到<code>collect</code>是一个将管道流的结果集到一个<code>list</code>中的结束操作。<code>collect</code>是一个将数据流缩减为一个值的归约操作。这个值可以是集合、映射，或者一个值对象。你可以使用<code>collect</code>达到以下目的：</p><span id="more"></span><ol><li><p>**将数据流缩减为一个单一值：**一个流执行后的结果能够被缩减为一个单一的值。单一的值可以是一个<code>Collection</code>，或者像int、double等的数值，再或者是一个用户自定义的值对象。</p></li><li><p>**将一个数据流中的元素进行分组：**根据任务类型将流中所有的任务进行分组。这将产生一个<code>Map&lt;TaskType, List&lt;Task&gt;&gt;</code>的结果，其中每个实体包含一个任务类型以及与它相关的任务。你也可以使用除了列表以外的任何其他的集合。如果你不需要与一任务类型相关的所有的任务，你可以选择产生一个<code>Map&lt;TaskType, Task&gt;</code>。这是一个能够根据任务类型对任务进行分类并获取每类任务中第一个任务的例子。</p></li><li><p>**分割一个流中的元素：**你可以将一个流分割为两组——比如将任务分割为要做和已经做完的任务。</p></li></ol><h2 id="Collector实际应用"><a href="#Collector实际应用" class="headerlink" title="Collector实际应用"></a>Collector实际应用</h2><p>为了感受到<code>Collector</code>的威力，让我们来看一下我们要根据任务类型来对任务进行分类的例子。在Java8中，我们可以通过编写如下的代码达到将任务根据类型分组的目的。<strong>请参考<a href="./03-streams.md">第二天</a>的博文，也就是我们讨论的在这一系列文章中我们将使用的任务域。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;TaskType, List&lt;Task&gt;&gt; <span class="hljs-title function_">groupTasksByType</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().collect(Collectors.groupingBy(task -&gt; task.getType()));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码使用了定义在辅助类<code>Collectors</code>中的<code>groupingBy</code>收集器。它创建了一个映射，其中<code>TaskType</code>是它的键，而包含了所有拥有相同<code>TaskType</code>的任务的列表是它的值。为了在Java7中达到相同的效果，你需要编写如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Task&gt; tasks = getTasks();<br>    Map&lt;TaskType, List&lt;Task&gt;&gt; allTasksByType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>        List&lt;Task&gt; existingTasksByType = allTasksByType.get(task.getType());<br>        <span class="hljs-keyword">if</span> (existingTasksByType == <span class="hljs-literal">null</span>) &#123;<br>            List&lt;Task&gt; tasksByType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            tasksByType.add(task);<br>            allTasksByType.put(task.getType(), tasksByType);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            existingTasksByType.add(task);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;TaskType, List&lt;Task&gt;&gt; entry : allTasksByType.entrySet()) &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;%s =&gt;&gt; %s&quot;</span>, entry.getKey(), entry.getValue()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="收集器：常用的规约操作"><a href="#收集器：常用的规约操作" class="headerlink" title="收集器：常用的规约操作"></a>收集器：常用的规约操作</h2><p><code>Collectors</code>辅助类提供了大量的静态辅助方法来创建收集器为常见的使用场景服务，像将元素收集到一个集合中、分组和分割元素，或者根据不同的标准来概述元素。我们将在这篇博文中涵盖大部分常见的<code>Collector</code>。</p><h2 id="缩减为一个值"><a href="#缩减为一个值" class="headerlink" title="缩减为一个值"></a>缩减为一个值</h2><p>正如上面讨论的，收集器可以被用来收集流的输出到一个集合，或者产生一个单一的值。</p><h3 id="将数据收集进一个列表"><a href="#将数据收集进一个列表" class="headerlink" title="将数据收集进一个列表"></a>将数据收集进一个列表</h3><p>让我们编写我们的第一个测试用例——给定一个任务列表，我们想将他们的标题收集进一个列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example2_ReduceValue</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">allTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        <span class="hljs-keyword">return</span> tasks.stream().map(Task::getTitle).collect(toList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>toList</code>收集器使用了列表的<code>add</code>方法来向结果列表中添加元素。<code>toList</code>收集器使用了<code>ArrayList</code>作为列表的实现。</p><h3 id="将数据收集进一个集合"><a href="#将数据收集进一个集合" class="headerlink" title="将数据收集进一个集合"></a>将数据收集进一个集合</h3><p>如果我们想要确保返回的标题都是唯一的，并且我们不在乎元素的顺序，那么我们可以使用<code>toSet</code>收集器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toSet;<br><br><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">uniqueTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().map(Task::getTitle).collect(toSet());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>toSet</code>方法使用了<code>HashSet</code>作为集合的实现来存储结果集。</p><h3 id="将数据收集进一个映射"><a href="#将数据收集进一个映射" class="headerlink" title="将数据收集进一个映射"></a>将数据收集进一个映射</h3><p>你可以使用<code>toMap</code>收集器将一个流转换为一个映射。<code>toMap</code>收集器需要两个映射方法来获得映射的键和值。在下面展示的代码中，<code>Task::getTitle</code>是接收一个任务并产生一个只包含该任务标题的键的<code>Function</code>。<strong>task -&gt; task</strong>是一个用来返回任务本身的lambda表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Task&gt; <span class="hljs-title function_">taskMap</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>  <span class="hljs-keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, task -&gt; task));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过使用<code>Function</code>接口中的默认方法<code>identity</code>来改进上面展示的代码，如下所示，这样可以让代码更加简洁，并更好地传达开发者的意图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.function.Function.identity;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Task&gt; <span class="hljs-title function_">taskMap</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>  <span class="hljs-keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, identity()));<br>&#125;<br></code></pre></td></tr></table></figure><p>从一个流中创建映射的代码会在存在重复的键时抛出异常。你将会得到一个类似下面的错误。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalStateException</span>: Duplicate key Task&#123;title=<span class="hljs-string">&#x27;Read Version Control with Git book&#x27;</span>, type=READING&#125;<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.Collectors</span>.lambda<span class="hljs-variable">$throwingMerger</span>$<span class="hljs-number">105</span>(Collectors<span class="hljs-selector-class">.java</span>:<span class="hljs-number">133</span>)<br></code></pre></td></tr></table></figure><p>你可以通过使用<code>toMap</code>方法的另一个变体来处理重复问题，它允许我们指定一个合并方法。这个合并方法允许用户他们指定想如何处理多个值关联到同一个键的冲突。在下面展示的代码中，我们只是使用了新的值，当然你也可以编写一个智能的算法来处理冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Task&gt; <span class="hljs-title function_">taskMap_duplicates</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>  <span class="hljs-keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, identity(), (t1, t2) -&gt; t2));<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以通过使用<code>toMap</code>方法的第三个变体来指定其他的映射实现。这需要你指定将用来存储结果的<code>Map</code>和<code>Supplier</code>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Task&gt; collectToMap(List&lt;Task&gt; tasks) &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">collect</span><span class="hljs-params">(toMap(Task::getTitle, identity(), (t1, t2) -&gt; t2, LinkedHashMap::<span class="hljs-keyword">new</span>))</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>类似于<code>toMap</code>收集器，也有<code>toConcurrentMap</code>收集器，它产生一个<code>ConcurrentMap</code>而不是<code>HashMap</code>。</p><h3 id="使用其它的收集器"><a href="#使用其它的收集器" class="headerlink" title="使用其它的收集器"></a>使用其它的收集器</h3><p>像<code>toList</code>和<code>toSet</code>这类特定的收集器不允许你指定内部的列表或者集合实现。当你想要将结果收集到其它类型的集合中时，你可以像下面这样使用<code>toCollection</code>收集器。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> LinkedHashSet&lt;<span class="hljs-built_in">Task</span>&gt; <span class="hljs-title">collectToLinkedHaskSet</span><span class="hljs-params">(List&lt;<span class="hljs-built_in">Task</span>&gt; tasks)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> tasks.<span class="hljs-built_in">stream</span>().<span class="hljs-built_in">collect</span>(<span class="hljs-built_in">toCollection</span>(LinkedHashSet::<span class="hljs-keyword">new</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找到拥有最长标题的任务"><a href="#找到拥有最长标题的任务" class="headerlink" title="找到拥有最长标题的任务"></a>找到拥有最长标题的任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Task <span class="hljs-title function_">taskWithLongestTitle</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().collect(collectingAndThen(maxBy((t1, t2) -&gt; t1.getTitle().length() - t2.getTitle().length()), Optional::get));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计标签的总数"><a href="#统计标签的总数" class="headerlink" title="统计标签的总数"></a>统计标签的总数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalTagCount</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().collect(summingInt(task -&gt; task.getTags().size()));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生成任务标题的概述"><a href="#生成任务标题的概述" class="headerlink" title="生成任务标题的概述"></a>生成任务标题的概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">titleSummary</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().map(Task::getTitle).collect(joining(<span class="hljs-string">&quot;;&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分类收集器"><a href="#分类收集器" class="headerlink" title="分类收集器"></a>分类收集器</h2><p>收集器最常见的使用场景之一是对元素进行分类。让我来看一下不同的例子来理解我们如何进行分类。</p><h3 id="例子1：根据类型对任务分类"><a href="#例子1：根据类型对任务分类" class="headerlink" title="例子1：根据类型对任务分类"></a>例子1：根据类型对任务分类</h3><p>我们看一下下面展示的例子，我们想要根据<code>TaskType</code>来对所有的任务进行分类。我们可以通过使用<code>Collectors</code>辅助类中的<code>groupingBy</code>方法来轻易地进行该项任务。你可以通过使用方法引用和静态导入来使它更加高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.groupingBy;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;TaskType, List&lt;Task&gt;&gt; <span class="hljs-title function_">groupTasksByType</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>       <span class="hljs-keyword">return</span> tasks.stream().collect(groupingBy(Task::getType));<br>&#125;<br></code></pre></td></tr></table></figure><p>它将会产生如下的输出。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;CODING=[Task&#123;<span class="hljs-attribute">title</span>=<span class="hljs-string">&#x27;Write a mobile application to store my tasks&#x27;</span>, <span class="hljs-attribute">type</span>=CODING, <span class="hljs-attribute">createdOn</span>=2015-07-03&#125;], WRITING=[Task&#123;<span class="hljs-attribute">title</span>=<span class="hljs-string">&#x27;Write a blog on Java 8 Streams&#x27;</span>, <span class="hljs-attribute">type</span>=WRITING, <span class="hljs-attribute">createdOn</span>=2015-07-04&#125;], READING=[Task&#123;<span class="hljs-attribute">title</span>=<span class="hljs-string">&#x27;Read Version Control with Git book&#x27;</span>, <span class="hljs-attribute">type</span>=READING, <span class="hljs-attribute">createdOn</span>=2015-07-01&#125;, Task&#123;<span class="hljs-attribute">title</span>=<span class="hljs-string">&#x27;Read Java 8 Lambdas book&#x27;</span>, <span class="hljs-attribute">type</span>=READING, <span class="hljs-attribute">createdOn</span>=2015-07-02&#125;, Task&#123;<span class="hljs-attribute">title</span>=<span class="hljs-string">&#x27;Read Domain Driven Design book&#x27;</span>, <span class="hljs-attribute">type</span>=READING, <span class="hljs-attribute">createdOn</span>=2015-07-05&#125;]&#125;<br></code></pre></td></tr></table></figure><h3 id="例子2：根据标签分类"><a href="#例子2：根据标签分类" class="headerlink" title="例子2：根据标签分类"></a>例子2：根据标签分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;Task&gt;&gt; <span class="hljs-title function_">groupingByTag</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        <span class="hljs-keyword">return</span> tasks.stream().<br>                flatMap(task -&gt; task.getTags().stream().map(tag -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskTag</span>(tag, task))).<br>                collect(groupingBy(TaskTag::getTag, mapping(TaskTag::getTask,toList())));<br>&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskTag</span> &#123;<br>        <span class="hljs-keyword">final</span> String tag;<br>        <span class="hljs-keyword">final</span> Task task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskTag</span><span class="hljs-params">(String tag, Task task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.tag = tag;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTag</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> tag;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> task;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="例子3：根据标签和数量对任务分类"><a href="#例子3：根据标签和数量对任务分类" class="headerlink" title="例子3：根据标签和数量对任务分类"></a>例子3：根据标签和数量对任务分类</h3><p>将分类器和收集器结合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Long&gt; <span class="hljs-title function_">tagsAndCount</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        <span class="hljs-keyword">return</span> tasks.stream().<br>        flatMap(task -&gt; task.getTags().stream().map(tag -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskTag</span>(tag, task))).<br>        collect(groupingBy(TaskTag::getTag, counting()));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="例子4：根据任务类型和创建日期分类"><a href="#例子4：根据任务类型和创建日期分类" class="headerlink" title="例子4：根据任务类型和创建日期分类"></a>例子4：根据任务类型和创建日期分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;TaskType, Map&lt;LocalDate, List&lt;Task&gt;&gt;&gt; <span class="hljs-title function_">groupTasksByTypeAndCreationDate</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        <span class="hljs-keyword">return</span> tasks.stream().collect(groupingBy(Task::getType, groupingBy(Task::getCreatedOn)));<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>很多时候你想根据一个断言来将一个数据集分割成两个数据集。举例来说，我们可以通过定义一个将任务分割为两组的分割方法来将任务分割成两组，一组是在今天之前已经到期的，另一组是其他的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Boolean, List&lt;Task&gt;&gt; <span class="hljs-title function_">partitionOldAndFutureTasks</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>  <span class="hljs-keyword">return</span> tasks.stream().collect(partitioningBy(task -&gt; task.getDueOn().isAfter(LocalDate.now())));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生成统计信息"><a href="#生成统计信息" class="headerlink" title="生成统计信息"></a>生成统计信息</h2><p>另一组非常有用的收集器是用来产生统计信息的收集器。这能够在像<code>int</code>、<code>double</code>和<code>long</code>这样的原始数据类型上起到作用；并且能被用来生成像下面这样的统计信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">summaryStatistics</span> <span class="hljs-operator">=</span> tasks.stream().map(Task::getTitle).collect(summarizingInt(String::length));<br>System.out.println(summaryStatistics.getAverage()); <span class="hljs-comment">//32.4</span><br>System.out.println(summaryStatistics.getCount()); <span class="hljs-comment">//5</span><br>System.out.println(summaryStatistics.getMax()); <span class="hljs-comment">//44</span><br>System.out.println(summaryStatistics.getMin()); <span class="hljs-comment">//24</span><br>System.out.println(summaryStatistics.getSum()); <span class="hljs-comment">//162</span><br></code></pre></td></tr></table></figure><p>也有其它的变种形式，像针对其它原生类型的<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>。</p><p>你也可以通过使用<code>combine</code>操作来将一个<code>IntSummaryStatistics</code>与另一个组合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">firstSummaryStatistics.combine(secondSummaryStatistics);<br>System.out.println(firstSummaryStatistics)<br></code></pre></td></tr></table></figure><h2 id="连接所有的标题"><a href="#连接所有的标题" class="headerlink" title="连接所有的标题"></a>连接所有的标题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">allTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>  <span class="hljs-keyword">return</span> tasks.stream().map(Task::getTitle).collect(joining(<span class="hljs-string">&quot;, &quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写一个定制的收集器"><a href="#编写一个定制的收集器" class="headerlink" title="编写一个定制的收集器"></a>编写一个定制的收集器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.collect.HashMultiset;<br><span class="hljs-keyword">import</span> com.google.common.collect.Multiset;<br><br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.EnumSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.function.BiConsumer;<br><span class="hljs-keyword">import</span> java.util.function.BinaryOperator;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><span class="hljs-keyword">import</span> java.util.stream.Collector;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultisetCollector</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collector</span>&lt;T, Multiset&lt;T&gt;, Multiset&lt;T&gt;&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Supplier&lt;Multiset&lt;T&gt;&gt; <span class="hljs-title function_">supplier</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> HashMultiset::create;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BiConsumer&lt;Multiset&lt;T&gt;, T&gt; <span class="hljs-title function_">accumulator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (set, e) -&gt; set.add(e, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BinaryOperator&lt;Multiset&lt;T&gt;&gt; <span class="hljs-title function_">combiner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (set1, set2) -&gt; &#123;<br>            set1.addAll(set2);<br>            <span class="hljs-keyword">return</span> set1;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Function&lt;Multiset&lt;T&gt;, Multiset&lt;T&gt;&gt; <span class="hljs-title function_">finisher</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Function.identity();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;Characteristics&gt; <span class="hljs-title function_">characteristics</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.collect.Multiset;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultisetCollectorExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;shekhar&quot;</span>, <span class="hljs-string">&quot;rahul&quot;</span>, <span class="hljs-string">&quot;shekhar&quot;</span>);<br>        Multiset&lt;String&gt; set = names.stream().collect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MultisetCollector</span>&lt;&gt;());<br><br>        set.forEach(str -&gt; System.out.println(str + <span class="hljs-string">&quot;:&quot;</span> + set.count(str)));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java8中的字数统计"><a href="#Java8中的字数统计" class="headerlink" title="Java8中的字数统计"></a>Java8中的字数统计</h2><p>我们将通过使用流和收集器在Java8中编写有名的字数统计样例来结束这一节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wordCount</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    Map&lt;String, Long&gt; wordCount = Files.lines(path)<br>            .parallel()<br>            .flatMap(line -&gt; Arrays.stream(line.trim().split(<span class="hljs-string">&quot;\\s&quot;</span>)))<br>            .map(word -&gt; word.replaceAll(<span class="hljs-string">&quot;[^a-zA-Z]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).toLowerCase().trim())<br>            .filter(word -&gt; word.length() &gt; <span class="hljs-number">0</span>)<br>            .map(word -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleEntry</span>&lt;&gt;(word, <span class="hljs-number">1</span>))<br>            .collect(groupingBy(SimpleEntry::getKey, counting()));<br>    wordCount.forEach((k, v) -&gt; System.out.println(String.format(<span class="hljs-string">&quot;%s ==&gt;&gt; %d&quot;</span>, k, v)));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8-Stream API</title>
    <link href="/2020/04/15/Stream-API/"/>
    <url>/2020/04/15/Stream-API/</url>
    
    <content type="html"><![CDATA[<p>在<a href="./2020/04/15/java8-lambda/">第二章</a>中，我们通过学习lambda表达式，了解了如何能够在不创建额外类的情况下传递行为来帮助我们编写出简洁精练的代码。lambda表达式是一种通过使用函数式接口让开发者能够快速表达他们的想法的语言概念。设计API的时候将lambda，也就是那些使用了函数式接口的流畅的API（我们在<a href="./02-lambdas.md#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8Java8%E4%B8%AD%E5%B7%A5%E4%BD%9C%E7%9A%84">lambdas章节</a>中讨论过它们）记在脑子中，我们才能真正体验到lambda的强大。  </p><span id="more"></span><p>在Java8中引进的Stream API是使用lambda的API之一。就像SQL如何帮助你在数据库中形象地查询数据，Stream在Java集合计算上提供了一个形象的声明式的高层抽象来表示计算。形象的意思是指开发者只要写他们想写的，而不是关注他们该如何来写。在这一章中，我们将讨论对一个新的数据处理API的需求、<code>Collection</code>和<code>Stream</code>的区别，和如何在你的应用中使用Stream API。</p><blockquote><p>这一节的代码在<a href="https://github.com/shekhargulati/java8-the-missing-tutorial/tree/master/code/src/main/java/com/shekhargulati/java8_tutorial/ch03">ch03</a>包中</p></blockquote><h2 id="为什么我们需要一个新的数据处理抽象"><a href="#为什么我们需要一个新的数据处理抽象" class="headerlink" title="为什么我们需要一个新的数据处理抽象"></a>为什么我们需要一个新的数据处理抽象</h2><p>在我的观点中，主要有两个原因：</p><ol><li><code>Collection</code> API没有提供高层的概念来查询数据，所以开发者被迫为琐碎的工作编写很多重复的代码。</li><li>对<code>Collection</code>的并行操作在语言支持方面受到了限制。只能让开发者用Java的并发机制来让数据并行处理快速而有效。</li></ol><h2 id="在Java8之前的数据处理"><a href="#在Java8之前的数据处理" class="headerlink" title="在Java8之前的数据处理"></a>在Java8之前的数据处理</h2><p>看下面的代码并试图说出它的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example1_Java7</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Task&gt; tasks = getTasks();<br><br>        List&lt;Task&gt; readingTasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>            <span class="hljs-keyword">if</span> (task.getType() == TaskType.READING) &#123;<br>                readingTasks.add(task);<br>            &#125;<br>        &#125;<br>        Collections.sort(readingTasks, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Task&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Task t1, Task t2)</span> &#123;<br>                <span class="hljs-keyword">return</span> t1.getTitle().length() - t2.getTitle().length();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Task readingTask : readingTasks) &#123;<br>            System.out.println(readingTask.getTitle());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码将阅读任务按照它们标题的长度进行排序后输出。Java7的开发者成天要写这类的代码。为了写一个这样简单的程序，我们编写了15行代码。上面提到的代码的最大问题不是开发者要编写的代码的数量，而是它丢失了开发者的意图，也就是过滤阅读任务，根据标题长度排序，和转换成字符串列表。</p><h2 id="Java8中的数据处理"><a href="#Java8中的数据处理" class="headerlink" title="Java8中的数据处理"></a>Java8中的数据处理</h2><p>如下所示，上述的代码可以通过Java8的<code>Stream</code> API简化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example1_Stream</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Task&gt; tasks = getTasks();<br><br>        List&lt;String&gt; readingTasks = tasks.stream()<br>                .filter(task -&gt; task.getType() == TaskType.READING)<br>                .sorted((t1, t2) -&gt; t1.getTitle().length() - t2.getTitle().length())<br>                .map(Task::getTitle)<br>                .collect(Collectors.toList());<br><br>        readingTasks.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码构建了一个由许多流式操作组成的管道流，下面对其一一讲解。</p><ul><li><strong>stream()</strong>: 通过在一个原始的集合上调用<code>stream</code>方法来创建一个流式管道流，而<code>tasks</code>就是<code>List&lt;Task&gt;</code>类型的。</li><li><strong>filter(Predicate<T>)</strong>: 这个操作从流中抽取符合断言的判定条件的元素。一旦你有了一个数据流，你可以在其上不调用或者多次调用中间操作。lambda表达式<code>task -&gt; task.getType() == TaskType.READING</code>定义了一个断言来过滤所有的阅读任务。该lambda表达式的类型为<code>java.util.function.Predicate&lt;Task&gt;</code>。</li><li><strong>sorted(Comparator<T>)</strong>:这个操作返回一个根据由lambda表达式定义的比较器进行排序后的元素组成的数据流。在上面的例子中，这个比较器是<code>(t1, t2) -&gt; t1.getTitle().length() - t2.getTitle().length()</code> 。</li><li><strong>map(Function&lt;T,R&gt;)</strong>: 这个操作对数据流中的元素都进行<code>Fuction&lt;T,R&gt;</code>的操作，并返回新的数据流。</li><li><strong>collect(toList())</strong>:这个操作将经过各种操作处理后的数据流中的元素收集到一个列表中。</li></ul><h3 id="为什么Java8编写的代码更好"><a href="#为什么Java8编写的代码更好" class="headerlink" title="为什么Java8编写的代码更好"></a>为什么Java8编写的代码更好</h3><p>我认为Java8的代码更好的理由如下：</p><ol><li>Java8的代码清晰地展现出开发者的意图，如过滤、排序等。</li><li>开发者通过Stream API的形式能够在一个高层的抽象上来表现出他们想要做什么，而不是他们如何来作。</li><li>Stream API为数据处理提供了一个统一的语言。现在当程序员讨论到数据处理时，它们将会有共同的词汇。当两个开发者谈论到<code>filter</code>方法时，你可以肯定他们都在使用一个数据过滤操作。</li><li>处理数据时不需要重复的代码。用户不需要写专门的<code>for</code>循环，也不用创建临时集合来存储数据。所有的工作都可以通过Stream API来完成。</li><li>Stream不会修改你原来的集合——它们是免于变化的。</li></ol><h2 id="什么是Stream？"><a href="#什么是Stream？" class="headerlink" title="什么是Stream？"></a>什么是Stream？</h2><p>Stream是一些数据上的抽象视图。举例来说，Stream可以是列表、文件中的每行数据，或者其他任意元素的序列的一个视图。Stream API提供了可以连续执行，或者并行执行的操作集合。<em><strong>开发者需要记住的是Stream是一个高层的抽象，而不是一个数据结构。Stream不会存储你的数据。</strong></em> Stream本身是<strong>懒惰</strong>的，只有使用到它们时才会开始计算。这使我们能够产生无数的数据流。在Java8中，你能够像下面一样编写一个Stream来产生无数的唯一标识码。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>    Stream&lt;<span class="hljs-built_in">String</span>&gt; uuidStream = Stream.generate<span class="hljs-function"><span class="hljs-params">(() -&gt; UUID.randomUUID().toString())</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>在Stream的接口中，有很多像<code>of</code>、<code>generate</code>和<code>iterate</code>一样的静态工厂方法，它们可以用来创建Stream的实例。上面展示的<code>generate</code>方法以<code>Supplier</code>为参数。<code>Supplier</code>是一个函数式接口，用来描述一个不需要参数并返回一个值的函数。我们传递给<code>generate</code>方法一个供应者，那么当调用的时候，就能产生一个唯一标识码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;String&gt; uuids = () -&gt; UUID.randomUUID().toString()<br></code></pre></td></tr></table></figure><p>如果我们运行上面的代码，那么什么都不会发生，因为Stream是懒惰的，它没有被使用之前，什么计算都不会进行。如果我们将代码更新成下面这样，我们将会看到在控制台上输出UUID。该程序将会不断运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Stream&lt;String&gt; uuidStream = Stream.generate(() -&gt; UUID.randomUUID().toString());<br>    uuidStream.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>Java8允许你在集合对象上调用<code>stream</code>方法来创建一个Stream。Stream支持数据处理操作，所以开发者可以用高层数据处理结构来表示计算过程。</p><h2 id="Collection-vs-Stream"><a href="#Collection-vs-Stream" class="headerlink" title="Collection vs Stream"></a>Collection vs Stream</h2><p>下面的表格解释了Collection和Stream之间的不同。</p><p><img src="https://whyjava.files.wordpress.com/2015/10/collection_vs_stream.png" alt="Collection vs Stream"></p><p>让我们来详细讨论一下外部迭代和内部迭代，以及延迟求值。</p><h3 id="外部迭代-vs-内部迭代"><a href="#外部迭代-vs-内部迭代" class="headerlink" title="外部迭代 vs 内部迭代"></a>外部迭代 vs 内部迭代</h3><p>上面所示的代码中，Java8中的Stream API和原来的Collection API的不同在于谁控制了迭代——是迭代器还是使用了迭代器的用户。Stream API的用户只是提供了他们想要使用的操作，然后迭代器将这些操作施加在内部集合中的每一个元素上。当迭代内部集合时，这个过程是由迭代器自己处理的，这被叫做<strong>内部迭代</strong>。而在Collection API中使用<code>for-each</code>结构是一个<strong>外部迭代</strong>的例子。</p><p>有些人可能会争论，在Collection API中我们不需要使用其中的迭代器，因为<code>for-each</code>结构将会处理它，但<code>for-each</code>只是使用了迭代器API的人工迭代的语法糖而已。<code>for-each</code>结构虽然很简单，却有一些缺点——1）他是内在连续的，2）它导致命令式代码，3）它很难并行化。</p><h3 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h3><p>Stream不会进行计算直到一个最终的命令来调用它。在Stream API中的大多数操作返回一个Stream。这些操作不会被执行——它们只是建立起管道流。让我们看一下下面的代码，并预测它的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Stream&lt;Integer&gt; stream = numbers.stream().map(n -&gt; n / <span class="hljs-number">0</span>).filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>在上面所示的代码中，我们将一个数字流中的元素除以0。我们也许认为当代码执行时，它会抛出一个<code>ArithmeticException</code>的异常。但是，当你运行该代码时不会有异常抛出。这是因为Stream不会计算直到一个最终的命令调用它。如果在该管道流中添加最终的调用方法，那么该Stream将会执行，并抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Stream&lt;Integer&gt; stream = numbers.stream().map(n -&gt; n / <span class="hljs-number">0</span>).filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br>stream.collect(toList());<br></code></pre></td></tr></table></figure><p>你将会得到类似下面的堆栈信息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArithmeticException</span>: / by zero<br>at org._7dayswithx<span class="hljs-selector-class">.java8</span><span class="hljs-selector-class">.day2</span><span class="hljs-selector-class">.EagerEvaluationExample</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(EagerEvaluationExample<span class="hljs-selector-class">.java</span>:<span class="hljs-number">13</span>)<br>at org._7dayswithx<span class="hljs-selector-class">.java8</span><span class="hljs-selector-class">.day2</span>.EagerEvaluationExample$<span class="hljs-variable">$Lambda</span>$<span class="hljs-number">1</span>/<span class="hljs-number">1915318863</span><span class="hljs-selector-class">.apply</span>(Unknown Source)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span>.ReferencePipeline$<span class="hljs-number">3</span>$<span class="hljs-number">1</span><span class="hljs-selector-class">.accept</span>(ReferencePipeline<span class="hljs-selector-class">.java</span>:<span class="hljs-number">193</span>)<br>at java<span class="hljs-selector-class">.util</span>.Spliterators<span class="hljs-variable">$ArraySpliterator</span><span class="hljs-selector-class">.forEachRemaining</span>(Spliterators<span class="hljs-selector-class">.java</span>:<span class="hljs-number">948</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.AbstractPipeline</span><span class="hljs-selector-class">.copyInto</span>(AbstractPipeline<span class="hljs-selector-class">.java</span>:<span class="hljs-number">512</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.AbstractPipeline</span><span class="hljs-selector-class">.wrapAndCopyInto</span>(AbstractPipeline<span class="hljs-selector-class">.java</span>:<span class="hljs-number">502</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span>.ReduceOps<span class="hljs-variable">$ReduceOp</span><span class="hljs-selector-class">.evaluateSequential</span>(ReduceOps<span class="hljs-selector-class">.java</span>:<span class="hljs-number">708</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.AbstractPipeline</span><span class="hljs-selector-class">.evaluate</span>(AbstractPipeline<span class="hljs-selector-class">.java</span>:<span class="hljs-number">234</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.ReferencePipeline</span><span class="hljs-selector-class">.collect</span>(ReferencePipeline<span class="hljs-selector-class">.java</span>:<span class="hljs-number">499</span>)<br></code></pre></td></tr></table></figure><h2 id="使用Stream-API"><a href="#使用Stream-API" class="headerlink" title="使用Stream API"></a>使用Stream API</h2><p>Stream API提供了很多开发者可以用来从集合中查询数据的操作。Stream操作分为两类——中间操作和结束操作。</p><p><strong>中间操作</strong>是从已有的Stream产生另一个Stream的函数，有<code>filter</code>、<code>map</code>、<code>sorted</code>等。</p><p><strong>结束操作</strong>是从Stream来产生一个不是Stream的结果的函数，有<code>collect(toList())</code>、<code>forEach</code>、<code>count</code>等。</p><p>中间操作允许你来构建管道流，它们会在你调用结束操作时被执行。下面是Stream API部分函数的列表。</p><p><a href="https://whyjava.files.wordpress.com/2015/07/stream-api.png"><img class="aligncenter size-full wp-image-2983" src="https://whyjava.files.wordpress.com/2015/07/stream-api.png" alt="stream-api" height="450" /></a></p><h3 id="示例域"><a href="#示例域" class="headerlink" title="示例域"></a>示例域</h3><p>在这个教程中，我们将使用任务管理域来解释概念。我们的示例域有一个叫做<code>Task</code>的类——一个由用户来执行的任务。这个类如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.LocalDate;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String title;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaskType type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LocalDate createdOn;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; tags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LocalDate dueOn;<br><br>    <span class="hljs-comment">// removed constructor, getter, and setter for brevity</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该例子的数据集如下所示。我们将在Stream API示例中都使用这个列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Task</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Read Version Control with Git book&quot;</span>, TaskType.READING, LocalDate.of(<span class="hljs-number">2015</span>, Month.JULY, <span class="hljs-number">1</span>)).addTag(<span class="hljs-string">&quot;git&quot;</span>).addTag(<span class="hljs-string">&quot;reading&quot;</span>).addTag(<span class="hljs-string">&quot;books&quot;</span>);<br><br><span class="hljs-type">Task</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Read Java 8 Lambdas book&quot;</span>, TaskType.READING, LocalDate.of(<span class="hljs-number">2015</span>, Month.JULY, <span class="hljs-number">2</span>)).addTag(<span class="hljs-string">&quot;java8&quot;</span>).addTag(<span class="hljs-string">&quot;reading&quot;</span>).addTag(<span class="hljs-string">&quot;books&quot;</span>);<br><br><span class="hljs-type">Task</span> <span class="hljs-variable">task3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Write a mobile application to store my tasks&quot;</span>, TaskType.CODING, LocalDate.of(<span class="hljs-number">2015</span>, Month.JULY, <span class="hljs-number">3</span>)).addTag(<span class="hljs-string">&quot;coding&quot;</span>).addTag(<span class="hljs-string">&quot;mobile&quot;</span>);<br><br><span class="hljs-type">Task</span> <span class="hljs-variable">task4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Write a blog on Java 8 Streams&quot;</span>, TaskType.WRITING, LocalDate.of(<span class="hljs-number">2015</span>, Month.JULY, <span class="hljs-number">4</span>)).addTag(<span class="hljs-string">&quot;blogging&quot;</span>).addTag(<span class="hljs-string">&quot;writing&quot;</span>).addTag(<span class="hljs-string">&quot;streams&quot;</span>);<br><br><span class="hljs-type">Task</span> <span class="hljs-variable">task5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Read Domain Driven Design book&quot;</span>, TaskType.READING, LocalDate.of(<span class="hljs-number">2015</span>, Month.JULY, <span class="hljs-number">5</span>)).addTag(<span class="hljs-string">&quot;ddd&quot;</span>).addTag(<span class="hljs-string">&quot;books&quot;</span>).addTag(<span class="hljs-string">&quot;reading&quot;</span>);<br><br>List&lt;Task&gt; tasks = Arrays.asList(task1, task2, task3, task4, task5);<br></code></pre></td></tr></table></figure><blockquote><p>我们在这一节中不会讨论Java8的日期时间API。现在只要把它当做可读性高的日期相关的API即可。</p></blockquote><h3 id="例子1：找到所有的阅读任务并按照它们的创建日期排序"><a href="#例子1：找到所有的阅读任务并按照它们的创建日期排序" class="headerlink" title="例子1：找到所有的阅读任务并按照它们的创建日期排序"></a>例子1：找到所有的阅读任务并按照它们的创建日期排序</h3><p>我们讨论的第一个例子是找到所有的阅读任务，并按照它们的创建日期进行排序。我们需要执行的操作如下：</p><ol><li>过滤所有的任务来找到任务类型为<code>READING</code>的任务。</li><li>将过滤后的结果按照<code>createdOn</code>域进行排序。</li><li>获得每个任务的标题。</li><li>将结果的标题收集到一个列表中。</li></ol><p>上面的四个操作可以被容易地转换为如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">allReadingTasks</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        List&lt;String&gt; readingTaskTitles = tasks.stream().<br>                filter(task -&gt; task.getType() == TaskType.READING).<br>                sorted((t1, t2) -&gt; t1.getCreatedOn().compareTo(t2.getCreatedOn())).<br>                map(task -&gt; task.getTitle()).<br>                collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> readingTaskTitles;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面展示的代码中，我们使用了Stream API如下的方法：</p><ul><li><strong>filter</strong>：允许你指定一个断言来从数据流中排除一些元素。断言<strong>task-&gt;task.getType() &#x3D;&#x3D;TaskType.READING</strong>选择了所有任务类型为<code>READING</code>的任务。</li><li><strong>sorted</strong>：允许你指定一个比较器来对数据流进行排序。在这个例子中，你根据创建的日期来进行排序。lambda表达式**(t1,t2)-&gt;t1.getCreatedOn().compareTo(t2.getCreatedOn())** 提供了<code>Comparator</code>函数式接口的<code>compare</code>方法的实现。</li><li><strong>map</strong>：这需要一个实现了<code>Function&lt;? super T, ? extends R&gt;</code>接口的lambda表达式来将一个数据流转化为另一个数据流。lambda表达式**task-&gt;task.getTitle()**将一个任务转化为一个标题。</li><li><strong>collect(toList())</strong>：这是一个结束操作，它收集结果中的阅读任务的标题并放入列表。</li></ul><p>我们可以像下面一样通过使用<code>Comparator</code>接口的<code>comparing</code>方法和方法引用来优化上面的Java8代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">allReadingTasks</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().<br>            filter(task -&gt; task.getType() == TaskType.READING).<br>            sorted(Comparator.comparing(Task::getCreatedOn)).<br>            map(Task::getTitle).<br>            collect(Collectors.toList());<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>从Java8开始，接口可以以静态方法和默认方法的形式来拥有方法的实现。这些内容在<a href="./01-default-static-interface-methods.md">第一节</a>中。</p></blockquote><p>在上面展示的代码中，我们用了一个由<code>Comparator</code>接口提供的静态辅助方法<code>comparing</code>，它以<code>Function</code>接口为参数，而<code>Function</code>方法提取一个<code>Comparable</code>的键，并返回一个根据该键进行比较的比较器。方法引用<code>Task::getCreatedOn</code>相当于一个<code>Function&lt;Task, LocalDate&gt;</code>。</p><p>如下所示，通过使用复合函数，我们可以轻易地通过在比较器上调用<code>reversed</code>方法来编写将元素反向排序的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">allReadingTasksSortedByCreatedOnDesc</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().<br>            filter(task -&gt; task.getType() == TaskType.READING).<br>            sorted(Comparator.comparing(Task::getCreatedOn).reversed()).<br>            map(Task::getTitle).<br>            collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例子2：找到唯一的任务"><a href="#例子2：找到唯一的任务" class="headerlink" title="例子2：找到唯一的任务"></a>例子2：找到唯一的任务</h3><p>假设我们的数据集中有重复的任务。如下所示，我们可以在数据流上使用<code>distinct</code>方法来轻易地去除重复元素从而得到唯一的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Task&gt; <span class="hljs-title function_">allDistinctTasks</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().distinct().collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>distinct</code>方法将一个数据流转化成另一个没有重复元素的数据流。它使用对象的<code>equals</code>方法来决定对象是否相等。根据对象<code>equals</code>方法的约定，当两个对象相等的时候，它们被认为是重复的，然后其中一个会从结果数据流中被移除。</p><h3 id="例子3：找到根据创建日期排序的前5名的阅读任务"><a href="#例子3：找到根据创建日期排序的前5名的阅读任务" class="headerlink" title="例子3：找到根据创建日期排序的前5名的阅读任务"></a>例子3：找到根据创建日期排序的前5名的阅读任务</h3><p><code>limit</code>方法可以用来将结果集限定为特定的大小。<code>limit</code>方法是一个逻辑短路操作，也就是说它不会遍历所有的元素来得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">topN</span><span class="hljs-params">(List&lt;Task&gt; tasks, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().<br>            filter(task -&gt; task.getType() == TaskType.READING).<br>            sorted(comparing(Task::getCreatedOn)).<br>            map(Task::getTitle).<br>            limit(n).<br>            collect(toList());<br>&#125;<br></code></pre></td></tr></table></figure><p>如下所示，你可以将<code>limit</code>方法和<code>skip</code>方法一起使用来创建分页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// page starts from 0. So to view a second page `page` will be 1 and n will be 5.</span><br>List&lt;String&gt; readingTaskTitles = tasks.stream().<br>                filter(task -&gt; task.getType() == TaskType.READING).<br>                sorted(comparing(Task::getCreatedOn).reversed()).<br>                map(Task::getTitle).<br>                skip(page * n).<br>                limit(n).<br>                collect(toList());<br></code></pre></td></tr></table></figure><h3 id="例子4：计算所有阅读任务的数量"><a href="#例子4：计算所有阅读任务的数量" class="headerlink" title="例子4：计算所有阅读任务的数量"></a>例子4：计算所有阅读任务的数量</h3><p>为了得到所有阅读任务的数量，我们可以在数据流上使用<code>count</code>方法。这个方法是一个结束操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countAllReadingTasks</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().<br>            filter(task -&gt; task.getType() == TaskType.READING).<br>            count();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例子5：从所有的任务中找出所有不同的标签"><a href="#例子5：从所有的任务中找出所有不同的标签" class="headerlink" title="例子5：从所有的任务中找出所有不同的标签"></a>例子5：从所有的任务中找出所有不同的标签</h3><p>为了找出所有不同的标签，我们需要进行如下的操作：</p><ol><li>为每一个任务提取标签。</li><li>将所有的标签收集进一个数据流。</li><li>将重复的标签除去。</li><li>最后将收集的结果放入一个列表。</li></ol><p>第一个和第二个操作可以通过在<code>tasks</code>数据流上使用<code>flatMap</code>操作来完成。<code>flatMap</code>操作将每次调用<code>tasks.getTags().stream()</code>产生的数据流合并到一个中。一旦我们将所有标签放入一个数据流中，我们可以仅仅通过<code>distinct</code>方法来获取所有不同的标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">allDistinctTags</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        <span class="hljs-keyword">return</span> tasks.stream().flatMap(task -&gt; task.getTags().stream()).distinct().collect(toList());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例子6：检查是否所有的阅读任务都有books标签"><a href="#例子6：检查是否所有的阅读任务都有books标签" class="headerlink" title="例子6：检查是否所有的阅读任务都有books标签"></a>例子6：检查是否所有的阅读任务都有<code>books</code>标签</h3><p>Stream API提供了方法让用户来检查数据集中元素的某一属性是否符合要求。这些方法是<code>allMatch</code>、<code>anyMatch</code>、<code>findFirst</code>和<code>findAny</code>。为了检查是否所有的阅读任务都一个名叫<code>books</code>的标签，我们可以编写如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAllReadingTasksWithTagBooks</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().<br>            filter(task -&gt; task.getType() == TaskType.READING).<br>            allMatch(task -&gt; task.getTags().contains(<span class="hljs-string">&quot;books&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>为了检查是否有阅读任务有<code>java8</code>标签，我们可以像下面这样使用<code>anyMatch</code>操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnyReadingTasksWithTagJava8</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().<br>            filter(task -&gt; task.getType() == TaskType.READING).<br>            anyMatch(task -&gt; task.getTags().contains(<span class="hljs-string">&quot;java8&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例子7：创建一个所有标题的总结"><a href="#例子7：创建一个所有标题的总结" class="headerlink" title="例子7：创建一个所有标题的总结"></a>例子7：创建一个所有标题的总结</h3><p>假设你想创建一个所有标题的总结。使用<code>reduce</code>操作，它将数据流缩减为一个值。<code>reduce</code>方法以将数据流中元素进行连接的lambda表达式为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">joinAllTaskTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> tasks.stream().<br>            map(Task::getTitle).<br>            reduce((first, second) -&gt; first + <span class="hljs-string">&quot; *** &quot;</span> + second).<br>            get();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例子8：与原始流一同工作"><a href="#例子8：与原始流一同工作" class="headerlink" title="例子8：与原始流一同工作"></a>例子8：与原始流一同工作</h3><p>除了作用在对象上的通用的数据流，Java8还提供了特殊的数据流来处理原始类型，像int、long和double。让我看一些原始数据流的例子。</p><p>为了创建一个范围的值，我们可以使用<code>range</code>方法，它能创建一个从0开始到9的数据流，它不包括10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p><code>rangeClosed</code>方法允许你创建包含右边界的数据流。所以下面的数据流将从1开始，到10结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>你也可以像下面这样通过<code>iterate</code>方法在原始数据流上创建一个无限的数据流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LongStream</span> <span class="hljs-variable">infiniteStream</span> <span class="hljs-operator">=</span> LongStream.iterate(<span class="hljs-number">1</span>, el -&gt; el + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>为过滤掉无限数据流中所有的偶数，我们可以编写如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">infiniteStream.filter(el -&gt; el % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>我们可以像下面这样通过使用<code>limit</code>操作来限制结果数据流的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">infiniteStream.filter(el -&gt; el % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).limit(<span class="hljs-number">100</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="例子9：从Arrays来创建数据流"><a href="#例子9：从Arrays来创建数据流" class="headerlink" title="例子9：从Arrays来创建数据流"></a>例子9：从Arrays来创建数据流</h3><p>如下所示，你可以通过使用<code>Arrays</code>类的静态方法<code>stream</code>来从数组创建数据流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] tags = &#123;<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;git&quot;</span>, <span class="hljs-string">&quot;lambdas&quot;</span>, <span class="hljs-string">&quot;machine-learning&quot;</span>&#125;;<br>Arrays.stream(tags).map(String::toUpperCase).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>你也可像下面这样从一个数组特定的起始下标到结束下标来创建一个数据流。在这里，起始下标被包含在内，而结束下标没有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(tags, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>).map(String::toUpperCase).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h2 id="并行数据流"><a href="#并行数据流" class="headerlink" title="并行数据流"></a>并行数据流</h2><p>你使用<code>Stream</code>抽象的一大优势就是这个库能够有效地管理并行，就像迭代器也在容器内部一样。你可以通过调用数据流的<code>parallel</code>方法来使一个数据流并行。<code>parallel</code>方法底层使用了jdk7的<code>fork-join</code> API。默认地，它会将线程数上升到与主机CPU数量相等的数目。在下面所示的代码中，我们将数字按照处理它们的线程来进行分组。你将会在第四章中学习到<code>collect</code>和<code>groupingBy</code>方法。现在只需要理解它们允许你根据一个键来将元素分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelStreamExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, List&lt;Integer&gt;&gt; numbersPerThread = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">160</span>)<br>                .parallel()<br>                .boxed()<br>                .collect(groupingBy(i -&gt; Thread.currentThread().getName()));<br><br>        numbersPerThread.forEach((k, v) -&gt; System.out.println(String.format(<span class="hljs-string">&quot;%s &gt;&gt; %s&quot;</span>, k, v)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序在我电脑上的输出如下所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ForkJoinPool<span class="hljs-selector-class">.commonPool-worker-7</span> &gt;&gt; <span class="hljs-selector-attr">[46, 47, 48, 49, 50]</span><br>ForkJoinPool<span class="hljs-selector-class">.commonPool-worker-1</span> &gt;&gt; <span class="hljs-selector-attr">[41, 42, 43, 44, 45, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130]</span><br>ForkJoinPool<span class="hljs-selector-class">.commonPool-worker-2</span> &gt;&gt; <span class="hljs-selector-attr">[146, 147, 148, 149, 150]</span><br><span class="hljs-selector-tag">main</span> &gt;&gt; <span class="hljs-selector-attr">[106, 107, 108, 109, 110]</span><br>ForkJoinPool<span class="hljs-selector-class">.commonPool-worker-5</span> &gt;&gt; <span class="hljs-selector-attr">[71, 72, 73, 74, 75]</span><br>ForkJoinPool<span class="hljs-selector-class">.commonPool-worker-6</span> &gt;&gt; <span class="hljs-selector-attr">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160]</span><br>ForkJoinPool<span class="hljs-selector-class">.commonPool-worker-3</span> &gt;&gt; <span class="hljs-selector-attr">[21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 76, 77, 78, 79, 80]</span><br>ForkJoinPool<span class="hljs-selector-class">.commonPool-worker-4</span> &gt;&gt; <span class="hljs-selector-attr">[91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145]</span><br></code></pre></td></tr></table></figure><p>不是每一个线程处理一样多的元素。你可以通过设置系统属性<code>System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;2&quot;)</code>来控制<code>fork-join</code>线程池的大小。</p><p>如下所示，另一个你可以使用到<code>parallel</code>操作的地方是你操作一个URL的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] urls = &#123;<span class="hljs-string">&quot;https://www.google.co.in/&quot;</span>, <span class="hljs-string">&quot;https://twitter.com/&quot;</span>, <span class="hljs-string">&quot;http://www.facebook.com/&quot;</span>&#125;;<br>Arrays.stream(urls).parallel().map(url -&gt; getUrlContent(url)).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>如果你要理解何时来使用并行数据流，我建议你阅读Doug Lea et al的这篇文章 <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html</a>。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8-lambda</title>
    <link href="/2020/04/15/java8-lambda/"/>
    <url>/2020/04/15/java8-lambda/</url>
    
    <content type="html"><![CDATA[<p>Java8中最重要的特性之一就是引入了lambda表达式。这能够使你的代码更加简练，并允许你将行为传递到各处。一段时间以来，Java因为自身的冗长和缺少函数式编程的能力而受到批评。随着函数式编程变得越来越流行和有价值，Java也在努力接受函数式编程。否则，Java将会变得没有价值。</p><span id="more"></span><p>Java8在使世界上最受欢迎的编程语言之一在接纳函数式编程的过程中向前迈了一大步。为了支持函数式编程，编程语言必须将函数作为<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6">第一类对象</a>。在Java8之前，如果没有使用一个匿名内部类模板是没法写出清晰的函数式代码的。随着lambda表达式的引入，函数已经成为第一类对象，并能够像其它变量一样被到处传递。</p><p>lambda表达式允许你定义一个不与标识符绑定的匿名函数。你可以像编程语言中的其它概念一样使用它们，比如变量的声明。当一个编程语言需要支持高阶函数时，就需要用到lambda表达式。高阶函数是指以其它函数作为参数或者返回函数作为结果的函数。</p><blockquote><p>这一节的代码在<a href="https://github.com/shekhargulati/java8-the-missing-tutorial/tree/master/code/src/main/java/com/shekhargulati/java8_tutorial/ch02">ch02</a>包中</p></blockquote><p>现在，随着在Java8中引进了lambda表达式，Java已经支持高阶函数。让我来看一个lambda表达式的典型例子——<code>Collections</code>类中的<code>sort</code>方法。<code>sort</code>方法有两种变体——一种以一个<code>List</code>作为参数，另一个以<code>List</code>和<code>Comparator</code>作为参数。如下面的代码块所示，第二种<code>sort</code>方法是一个接受lambda表达式的高阶函数的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;shekhar&quot;</span>, <span class="hljs-string">&quot;rahul&quot;</span>, <span class="hljs-string">&quot;sameer&quot;</span>);<br>Collections.sort(names, (first, second) -&gt; first.length() - second.length());<br></code></pre></td></tr></table></figure><p>上面的代码将姓名链表按照元素的长度进行排序。该程序的输出如下所示。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[rahul, sameer, shekhar]</span><br></code></pre></td></tr></table></figure><p>上面代码块中的表达式<code>(first, second) -&gt; first.length() - second.length()</code>是一个<code>Comparator&lt;String&gt;</code>类型的lambda表达式。</p><ul><li><code>(first, second)</code>是比较器<code>Comparator</code>的<code>compare</code>方法。</li><li><code>first.length() - second.length()</code> 是用来比较两个名字长度的方法实体。</li><li><code>-&gt;</code>是lambda操作符，用来将参数和方法体分离开。</li></ul><p>在我们继续深挖Java8的lambda表达式之前，让我们来看看lambda的历史来理解为什么会存在lambda。</p><h2 id="lambda的历史"><a href="#lambda的历史" class="headerlink" title="lambda的历史"></a>lambda的历史</h2><p>lambda表达式源自λ演算。<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">λ演算</a>由<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87">Alonzo Church</a>在将带有函数的符号计算进行公式化时提出。λ演算是具有图灵完备性的，它通过数学形式来展现计算过程。图灵完备性表示你可以通过lambda表达任何的数学计算。</p><p>λ演算成为了函数式编程语言的一个坚实的理论基础。很多有名的函数式编程语言，像Haskell和Lisp都是构建在λ演算的基础上的。高阶函数的概念，比如接受其他函数为输入的函数也来自λ演算。</p><p>λ演算的核心概念是表达式。一个lambda表达式可以表示为如下形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span> := <span class="hljs-tag">&lt;<span class="hljs-name">variable</span>&gt;</span> | <span class="hljs-tag">&lt;<span class="hljs-name">function</span>&gt;</span>| <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>variable</strong>–变量就是类似x,y,z的占位符，它们用来表示具体的像1,2之类的值，或者lambda方法。</li><li><strong>functrion</strong>–这是一个匿名的方法定义，它需要一个变量，并产生另一个lambda表达式。例如，<code>λx.x*x</code>是一个用来计算数的平方的方法。</li><li><strong>application</strong>–这是将具体的参数应用在函数上的行为。假设你想得到10的平方，那么在λ演算中你会写一个平方函数<code>λx.x*x</code>，并把10代入。这个函数应用将得到<code>(λx.x*x) 10 = 10*10 = 100</code>。你不仅仅能够代入简单的像10一样的值，你可以将一个函数代入另一个函数来得到一个新的函数。例如，<code>(λx.x*x) (λz.z+10)</code>将会生成一个函数<code>λz.(z+10)*(z+10)</code>。现在，你可以用这个函数得到一个数加上10以后的平方。这是一个高阶函数的例子。</li></ul><p>现在你理解了λ演算和它在函数式编程语言中的影响。让我们来学习它是如何在Java8中实现的。</p><h2 id="在Java8之前传递行为的方式"><a href="#在Java8之前传递行为的方式" class="headerlink" title="在Java8之前传递行为的方式"></a>在Java8之前传递行为的方式</h2><p>在Java8之前，唯一能够用来传递行为的方式是通过匿名类。假设你想要在用户完成注册的同时在另一个线程中给该用户发送一封邮件。在Java8之前，你会写出类似下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">sendEmail(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Sending email...&quot;</span>);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p><code>sendEmail</code>方法拥有如下的方法签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">(Runnable runnable)</span><br></code></pre></td></tr></table></figure><p>上面提到的代码的问题不仅仅是我们需要封装我们的行为，如将<code>run</code>方法直接放在一个对象中，更严重的问题是它丢失了程序员的意图，如将行为传递到<code>sendEmail</code>方法中。如果你使用过Guava类库，你肯定感受到了编写匿名类的痛苦。一个简单的用来过滤所有任务的标题中有<strong>lambda</strong>的例子如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterable&lt;Task&gt; lambdaTasks = Iterables.filter(tasks, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Task&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Task task)</span> &#123;<br>                <span class="hljs-keyword">return</span> input.getTitle().contains(<span class="hljs-string">&quot;lambda&quot;</span>);<br>            &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>有了Java8的Stream API，你可以在不使用像Guava一样的第三方库的情况下写出上面提及的代码。我们将在<a href="">第三章</a>中讲解Stream，敬请期待。</p><h2 id="Java8-lambda表达式"><a href="#Java8-lambda表达式" class="headerlink" title="Java8 lambda表达式"></a>Java8 lambda表达式</h2><p>在Java8中，我们将使用lambda表达式写出如下的代码。这与我们上面提及过的代码段相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sendEmail(() -&gt; System.out.println(<span class="hljs-string">&quot;Sending email...&quot;</span>));<br></code></pre></td></tr></table></figure><p>上面的展示的代码非常简练，也没有污染程序员想要传递的行为。<code>()</code>用来表示这个lambda表达式没有参数，像<code>Runnable</code>接口中的<code>run</code>方法就没有任何参数。<code>-&gt;</code>是将参数和用来打印出<code>Sending email</code>的方法主体分隔开的lambda操作符。</p><p>让我再来看看<code>Collections.sort</code>这个例子来了解lambda表达式是如何使用参数的。为了使名字能够按照它们的长度进行排列，我们向排序方法传入了一个<code>Comparator</code>。该<code>Comparator</code>如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;String&gt; comparator = (first, second) -&gt; first.length() - second.length();<br></code></pre></td></tr></table></figure><p>我们编写的lambda表达式与<code>Comparator</code>接口中的<code>compare</code>方法相关联。<code>compare</code>方法的签名如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br></code></pre></td></tr></table></figure><p><code>T</code>是传给<code>Comparator</code>接口的类型参数。由于我们是对一组表示名字的字符串进行操作，所以这个例子中它将是字符串类型的。在lambda表达式中我们不需要特意提供该类型——字符串。<code>javac</code>编译器会从上下文中推断出它的类型信息。由于我们在给一组字符串排序，Java编译器会推测出两个参数都应该是字符串，而<code>compare</code>方法只标明需要<code>T</code>这一种类型。像这样通过上下文推断类型的行为称作类型推断。Java8优化了Java原有的类型推断机制，使得它更具有鲁棒性，并能够更好地支持lambda表达式。<code>javac</code>会在后台寻找与你lambda表达式相关的信息，并使用该信息来找到参数正确的类型。</p><blockquote><p>在大多数情况下，<code>javac</code>会从上下文中推断出类型。如果由于上下文缺失或不完整导致代码不能进行编译，它也就不能推断出类型。例如如果我们将<code>String</code>的类型信息从<code>Comparator</code>中移除，那么代码会像下面一样编译失败。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Comparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> (first, second) -&gt; first.length() - second.length(); <span class="hljs-comment">// compilation error - Cannot resolve method &#x27;length()&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="lambda表达式是如何在Java8中工作的？"><a href="#lambda表达式是如何在Java8中工作的？" class="headerlink" title="lambda表达式是如何在Java8中工作的？"></a>lambda表达式是如何在Java8中工作的？</h2><p>你也许已经发现lambda表达式是与上面例子中的<code>Comparator</code>类似的一些接口。你不能对任意的接口使用lambda表达式。***只有那些除了Object的方法外只定义了唯一抽象方法的接口可以使用lambda表达式。<em><strong>这一类的接口被称作</strong>函数式接口</em>*，它们可以通过<code>@FunctionalInterface</code>注解来进行注解。如下所示，<code>Runnable</code>接口就是一个函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@FunctionalInterface</code>注解不是强制需要的，它能够帮助其他工具知道这个接口是一个函数式接口，以此展现出有意义的行为。如果你试图编译一个有<code>@FunctionalInterface</code>的接口，而该接口有多个抽象方法，那么编译器将会抛出一个<em><strong>发现多个没有重写的抽象方法</strong></em>的异常。同样的，如果你对一个没有任何方法的接口添加<code>@FunctionalInterface</code>的注解，比如一个标记接口，那么你将会得到一条<em><strong>没有找到目标方法的</strong></em>的消息。</p><p>让我们来解答一个你也许会想到的最重要的问题。***Java8中的lambda表达式是仅仅针对匿名类的语法糖吗，或者说函数式接口是如何转换为字节码的？<em><strong>简单的答案是</strong>不是</em>*。Java8不使用匿名内部类主要有两个原因：</p><ol><li><p><strong>性能开销</strong>：如果lambda表达式是通过使用匿名类来实现的，那么每一个lambda表达式都要在磁盘上产生一个文件。如果这些类在JVM启动时被加载，那么JVM的启动时间将会增加，因为所有的类在使用前都要进行加载和验证。</p></li><li><p><strong>未来改变的可能性</strong>：如果Java8的设计者从开始就使用了匿名类，那么这将限制lambda表达式的实现方式在将来的变化。</p></li></ol><h3 id="使用invokedynamic"><a href="#使用invokedynamic" class="headerlink" title="使用invokedynamic"></a>使用invokedynamic</h3><p>Java8设计者决定使用在Java7中添加的<code>invokedynamic</code>指令来在运行时推迟编译策略的执行。当<code>javac</code>编译代码的时候，它会捕捉到lambda表达式并生成一个<code>invokedynamic</code>的调用（被叫做lambda工厂）。当<code>invokedynamic</code>命令被调用时，它会返回一个lambda要转化的函数式接口的实例。例如，我来查看<code>Collections.sort</code>的字节码，它如下所示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>    <span class="hljs-attr">Code:</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">iconst_3</span><br>       <span class="hljs-attr">1:</span> <span class="hljs-string">anewarray</span>     <span class="hljs-comment">#2                  // class java/lang/String</span><br>       <span class="hljs-attr">4:</span> <span class="hljs-string">dup</span><br>       <span class="hljs-attr">5:</span> <span class="hljs-string">iconst_0</span><br>       <span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#3                  // String shekhar</span><br>       <span class="hljs-attr">8:</span> <span class="hljs-string">aastore</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">dup</span><br>      <span class="hljs-attr">10:</span> <span class="hljs-string">iconst_1</span><br>      <span class="hljs-attr">11:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String rahul</span><br>      <span class="hljs-attr">13:</span> <span class="hljs-string">aastore</span><br>      <span class="hljs-attr">14:</span> <span class="hljs-string">dup</span><br>      <span class="hljs-attr">15:</span> <span class="hljs-string">iconst_2</span><br>      <span class="hljs-attr">16:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#5                  // String sameer</span><br>      <span class="hljs-attr">18:</span> <span class="hljs-string">aastore</span><br>      <span class="hljs-attr">19:</span> <span class="hljs-string">invokestatic</span>  <span class="hljs-comment">#6                  // Method java/util/Arrays.asList:([Ljava/lang/Object;)Ljava/util/List;</span><br>      <span class="hljs-attr">22:</span> <span class="hljs-string">astore_1</span><br>      <span class="hljs-attr">23:</span> <span class="hljs-string">invokedynamic</span> <span class="hljs-comment">#7,  0              // InvokeDynamic #0:compare:()Ljava/util/Comparator;</span><br>      <span class="hljs-attr">28:</span> <span class="hljs-string">astore_2</span><br>      <span class="hljs-attr">29:</span> <span class="hljs-string">aload_1</span><br>      <span class="hljs-attr">30:</span> <span class="hljs-string">aload_2</span><br>      <span class="hljs-attr">31:</span> <span class="hljs-string">invokestatic</span>  <span class="hljs-comment">#8                  // Method java/util/Collections.sort:(Ljava/util/List;Ljava/util/Comparator;)V</span><br>      <span class="hljs-attr">34:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-attr">37:</span> <span class="hljs-string">aload_1</span><br>      <span class="hljs-attr">38:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#10                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br>      <span class="hljs-attr">41:</span> <span class="hljs-string">return</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>该字节码有意思的地方在第23行<code>23: invokedynamic #7,  0              // InvokeDynamic #0:compare:()Ljava/util/Comparator;</code>，也就是生成一个<code>invokedynamic</code>的地方。</p><p>第二步是将lambda表达式的主体部分转化成通过<code>invokedynamic</code>指令调用的方法。这一步让JVM实现者能够自由地选取他们自己的策略。我省略了这个话题相关的内容，你可以在<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html%E4%B8%AD%E9%98%85%E8%AF%BB%E5%88%B0%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html中阅读到更多的内容。</a></p><h2 id="匿名类-vs-lambda"><a href="#匿名类-vs-lambda" class="headerlink" title="匿名类 vs lambda"></a>匿名类 vs lambda</h2><p>让我们通过比较匿名类和lambda表达式来比较它们的不同。</p><ol><li>在匿名类中，<code>this</code>表示匿名类自己，而在lambda表达式中，<code>this</code>表示包含了lambda表达式的类。</li><li>你可以在匿名类这个封闭类中隐藏变量。在lambda表达式中这么做时将产生一个编译错误。</li><li>lambda表达式的类型是由上下文决定的，而匿名类的类型是由你创建匿名类时指定的。</li></ol><h2 id="我需要自己编写函数式接口吗？"><a href="#我需要自己编写函数式接口吗？" class="headerlink" title="我需要自己编写函数式接口吗？"></a>我需要自己编写函数式接口吗？</h2><p>Java8默认提供了好多函数式编程接口来供你在代码中使用。它们在<code>java.util.function</code>包中。让我们看一下其中的一部分。</p><h3 id="java-util-function-Predicate"><a href="#java-util-function-Predicate" class="headerlink" title="java.util.function.Predicate"></a>java.util.function.Predicate<T></h3><p>这个函数式接口被用来定义某些情形的检查，类似于断言。<code>Predicate</code>接口有一个叫做<code>test</code>的方法，它以泛型<code>T</code>为参数，返回一个布尔值。举例来说，如果我们想从一串名字中找到所有以<strong>s</strong>开头的名字，那么我们将向下面这样使用<code>Predicate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;String&gt; namesStartingWithS = name -&gt; name.startsWith(<span class="hljs-string">&quot;s&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="java-util-function-Consumer"><a href="#java-util-function-Consumer" class="headerlink" title="java.util.function.Consumer"></a>java.util.function.Consumer<T></h3><p>这个函数式接口被用来执行一些不用产生输出的动作。<code>Comsumer</code>接口有一个以泛型<code>T</code>为参数且没有返回值的<code>accept</code>方法。比如将一条给定的信息通过邮件发出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; messageConsumer = message -&gt; System.out.println(message);<br></code></pre></td></tr></table></figure><h3 id="java-util-function-Function"><a href="#java-util-function-Function" class="headerlink" title="java.util.function.Function&lt;T,R&gt;"></a>java.util.function.Function&lt;T,R&gt;</h3><p>这个函数式接口接受一个参数并产生一个结果。例如，如果我们想要将姓名列表中的所有名字都大写，我们可以写一个像下面这样的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;String, String&gt; toUpperCase = name -&gt; name.toUpperCase();<br></code></pre></td></tr></table></figure><h3 id="java-util-function-Supplier"><a href="#java-util-function-Supplier" class="headerlink" title="java.util.function.Supplier"></a>java.util.function.Supplier<T></h3><p>这个函数式接口不需要任何参数，却会产生一个值。这可以被用来像下面这样生成唯一标志码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;String&gt; uuidGenerator= () -&gt; UUID.randomUUID().toString();<br></code></pre></td></tr></table></figure><p>我们将在这一系列教程中涉及更多的函数式接口。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>有时候你会创建一些只调用特定方法的lambda表达式，比如<code>Function&lt;String, Integer&gt; strToLength = str -&gt; str.length();</code>。这个lambda只在<code>String</code>对象上调用<code>length()</code>方法。这种情况可以通过使用方法引用来简化成<code>Function&lt;String, Integer&gt; strToLength = String::length;</code>。这可以被看做是只调用单个方法的lambda表达式的简化标记。在该表达式<code>String::length</code>中，<code>String</code>是目标引用，<code>::</code>是分隔符，<code>length</code>是在目标引用中将会被调用的方法。你在静态方法和实例方法中都可以使用方法引用。</p><h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>假设我们要找到一串数中最大的一个，那么我们可以写一个像<code>Function&lt;List&lt;Integer&gt;, Integer&gt; maxFn = Collections::max</code>这样的方法引用。<code>max</code>是<code>Collections</code>类中一个以<code>list</code>为参数的静态方法。然后你可以像<code>maxFn.apply(Arrays.asList(1, 10, 3, 5))</code>这样来调用。上面的lambda表达式是与<code>Function&lt;List&lt;Integer&gt;, Integer&gt; maxFn = (numbers) -&gt; Collections.max(numbers);</code>等价的。</p><h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>这是一类为实例方法使用的方法引用，比如在<code>String::toUpperCase</code>在<code>String</code>引用上调用了<code>toUpperCase</code>方法。你也可以对有参数的方法使用方法引用，像<code>BiFunction&lt;String, String, String&gt; concatFn = String::concat</code>。<code>concatFn</code>可以像<code>concatFn.apply(&quot;shekhar&quot;, &quot;gulati&quot;)</code>这样被调用。<code>concat</code>方法是字符串对象的需要一个参数的方法，形式为<code>&quot;shekhar&quot;.concat(&quot;gulati&quot;)</code>。</p><h2 id="练习-写自己的lambda"><a href="#练习-写自己的lambda" class="headerlink" title="练习&gt;&gt;写自己的lambda"></a>练习&gt;&gt;写自己的lambda</h2><p>让我们看一下下面的代码，并把我们学的应用起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exercise_Lambdas</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Task&gt; tasks = getTasks();<br>        List&lt;String&gt; titles = taskTitles(tasks);<br>        <span class="hljs-keyword">for</span> (String title : titles) &#123;<br>            System.out.println(title);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">taskTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        List&lt;String&gt; readingTitles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>            <span class="hljs-keyword">if</span> (task.getType() == TaskType.READING) &#123;<br>                readingTitles.add(task.getTitle());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> readingTitles;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码首先从一个工具方法<code>getTasks</code>中获取所有的任务。我们对<code>getTasks</code>方法的内部实现不感兴趣。<code>getTasks</code>方法可以从web、数据库或者内存中来获取任务。一旦你有了任务，我们过滤出所有的阅读任务并抽取出这些任务的标题。我们将抽取的标题存入一个链表并最终返回所有的阅读标题。</p><p>让我们从最简单的重构开始——通过方法引用在链表上使用<code>foreach</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exercise_Lambdas</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Task&gt; tasks = getTasks();<br>        List&lt;String&gt; titles = taskTitles(tasks);<br>        titles.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">taskTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks)</span> &#123;<br>        List&lt;String&gt; readingTitles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>            <span class="hljs-keyword">if</span> (task.getType() == TaskType.READING) &#123;<br>                readingTitles.add(task.getTitle());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> readingTitles;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>Predicate&lt;T&gt;</code>来过滤我们的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exercise_Lambdas</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Task&gt; tasks = getTasks();<br>        List&lt;String&gt; titles = taskTitles(tasks, task -&gt; task.getType() == TaskType.READING);<br>        titles.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">taskTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks)</span> &#123;<br>        List&lt;String&gt; readingTitles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>            <span class="hljs-keyword">if</span> (filterTasks.test(task)) &#123;<br>                readingTitles.add(task.getTitle());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> readingTitles;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>Function&lt;T,R&gt;</code>来从我们的任务中抽取标题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exercise_Lambdas</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Task&gt; tasks = getTasks();<br>        List&lt;String&gt; titles = taskTitles(tasks, task -&gt; task.getType() == TaskType.READING, task -&gt; task.getTitle());<br>        titles.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;R&gt; List&lt;R&gt; <span class="hljs-title function_">taskTitles</span><span class="hljs-params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks, Function&lt;Task, R&gt; extractor)</span> &#123;<br>        List&lt;R&gt; readingTitles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>            <span class="hljs-keyword">if</span> (filterTasks.test(task)) &#123;<br>                readingTitles.add(extractor.apply(task));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> readingTitles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对提取器使用方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Task&gt; tasks = getTasks();<br>    List&lt;String&gt; titles = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Task::getTitle);<br>    titles.forEach(System.out::println);<br>    List&lt;LocalDate&gt; createdOnDates = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Task::getCreatedOn);<br>    createdOnDates.forEach(System.out::println);<br>    List&lt;Task&gt; filteredTasks = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Function.identity());<br>    filteredTasks.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以通过编写我们自己的<strong>函数式接口</strong>，这样可以清楚地描述开发者的意图。我们可以创建一个继承于<code>Function</code>接口的<code>TaskExtractor</code>接口。该接口的输入类型被限定为<code>Task</code>，输出类型由lambda的实现决定。这样由于输入类型始终是<code>Task</code>，开发者只需要关注返回值的类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exercise_Lambdas</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Task&gt; tasks = getTasks();<br>        List&lt;Task&gt; filteredTasks = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, TaskExtractor.identityOp());<br>        filteredTasks.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;R&gt; List&lt;R&gt; <span class="hljs-title function_">filterAndExtract</span><span class="hljs-params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks, TaskExtractor&lt;R&gt; extractor)</span> &#123;<br>        List&lt;R&gt; readingTitles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Task task : tasks) &#123;<br>            <span class="hljs-keyword">if</span> (filterTasks.test(task)) &#123;<br>                readingTitles.add(extractor.apply(task));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> readingTitles;<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TaskExtractor</span>&lt;R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&lt;Task, R&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> TaskExtractor&lt;Task&gt; <span class="hljs-title function_">identityOp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
